---
layout: post
title: c++编程之面向对象
author: 刘邦
excerpt: "c++面相对象编程基础"
date: "2018-02-13"
catalog: true
tags: [c++]
category: c++
comments: true
---

[原文地址:https://www.ntu.edu.sg/home/ehchua/programming/cpp/cp3_OOP.html](https://www.ntu.edu.sg/home/ehchua/programming/cpp/cp3_OOP.html)


# 1. 为什么要使用OOP？

假如你想组装一台电脑，你会去硬件商店购买主板、处理器、内存条、硬盘、机箱、电源，然后将它们组装在一起，然后打开电源，电脑就能运行。
你不用考虑主板是4重板还是6重板，硬盘是什么尺寸，内存是哪里生产的诸如此类的问题。你只需要将这些硬件单元组合在一起，就能期待电脑能够运行。
当然，你需要保证你有正确的接口，比如，如果你的主板只支持IDE接口，而你需要购买一个IDE的硬盘而不是SCSI硬盘，又例如你需要选择一个合适速率的
内存。即便如此，将硬件组件组装成一台机器也没有任何难度。

同样的，一辆车也是由多个部分组装起来的，例如底盘、车门、引擎、车轮、刹车和传动装置。这些组件都是可复用的。比如车轮，就能够被用于很多辆同型号的骑车上。

像电脑和汽车这样的硬件能够用可复用的部分组装起来。那么软件是否也是如此呢？我们是否能够将不同地方的程序片段“组装”起来，然后期待程序能正常运行呢？
答案显然是no！跟硬件不同的是，很难从软件片段中“组装”一个应用。自从计算机60年前问世以来，人们写了大量的程式码。然而，对于每一个新的应用程序，我们都需要
重新造轮子。

为什么要重新造轮子呢？

## 1.1 传统的面向过程的编程语言

![](/img/2018-02-13/OOP_CFunction.png)

传统的面相过程的编程语言（例如C和Pascal）在创建可重用组件方面遇到了一些显著的缺陷：

1. 程序是由函数组织起来的。函数通常是不可重用的，我们很难将一个函数直接拷贝到别的地方去使用，因为函数很有可能引用了头文件，或者全局变量，或者调用了其他函数。
换句话说，函数不能很好的封装成一个独立的可重用单元。

2. 面相过程的语言不适合高层抽象来解决现实生活中的问题。例如c程序使用"if-else", "for-loop", "array", "function", "pointer"等结构，这些结构很低阶而且很难抽象形如
Customer Relationship Management (CRM) 系统或者电脑足球游戏。

简而言之，传统的面向过程的编程语言将数据结构和算法单元分开了。


## 1.2 面相对象的编程语言

![](/img/2018-02-13/OOP_Objects.png)

面相对象的编程语言就是被设计来克服这些问题的。

1. OOP的基础单元是类。类将静态属性和动态行为封装在一起，同时指定一些公开的接口来供人使用。由于相比于函数，类有很好的封装性，所以很容易重用。换句话说，类将数据和算法结合在了一起。

2. 面相对象的编程语言为解决现实问题的高阶抽象提供了保证。面相过程的编程语言迫使人们把注意力放在计算机结构（如：内存，位，字节，数组）上，而不是放在要解决的问题本身。面相对象的编程语言
能够让我们更专注于问题本身，使用程序对象来表示和抽象问题中的各种实体。

举个例子，假设你要写一个足球游戏，很难用面相过程的语言建立模型。但是使用OOP，可以很容易将现实事物同程序之间建立模型：

- Player：属性包含name, number, location等待，操作有run, jump, kick-the-ball...
- Ball:
- Reference:
- Field:
- Audience:
- Weather:

最重要的是，这其中的一些类（例如：Ball和Audience）可以在其他程序中复用。

## 1.3 OOP带来的优点

面相过程的编程语言注重于过程，函数是它的基础单元。你需要在一开始就规划好所有的函数，然后考虑如何去表示数据。

面相对象的编程语言注重于用户所认知的组件，类是它的基础单元。你只需要将所有数据和数据交互的操作放进对应的类中即可。

面相对象编程技术有很多优点：

- 易于设计和开发
- 易于维护
- 可复用


# 2. OOP基础

## 2.1 类和实例

> 类：类是对同种事物的抽象。换句话说，类是蓝图，是模板，或者是一种协议，类用来定义和描述同种对象共有的静态属性和动态行为。

> 实例：实例是一个类的特定实现。换句话说，实例是类的实例化。类的所有实例都具有类似的属性，如类定义中所描述的那样。

## 2.2 类是一个封装数据和操作的三室盒

一个类可以被形象的比喻成一个三室盒：

![](/img/2018-02-13/OOP_ThreeCompartment.png)

1. **Classname**(identifier)：标识类
2. **Data Members** or **Variables**(or attributes, states, fields)：包含了类的静态属性
3. **Member Functions**(or methods, behaviors, operations)：包含了类的动态操作

## 2.3 定义类

在C++种，使用关键字`class`来定义一个类。在申明类的时候可以有两张选项：`public`和`private`，稍后会具体说明。

```c++
class Circle {
private:
	double radius;
	string color;

public:
	double getRadius();
	double getArea();
}

```

```c++
class SoccerPlayer {
private:
	int number;
	string name;
	int x, y;

public:
	void run();
	void kickBall();
}
```

类命名约定：一个类名必须是一个名词或者一个名词短语，所有单词首字母大写（驼峰），使用名词单数形式，类名必须要有
意义，能够清楚描述自己。

## 2.4 创建类实例

创建一个类实例，你需要：

1. 申明一个特定实例的标识符。
2. 调用类的构造函数来构造类的实例

假如我们有一个名为`Circle`的类，我们可以通过如下方式来创建实例：

```c++
Circle c1(1.2, "red");
Circle c2(3.4);
Circle c3();
```

另外，你也可以显示调用构造函数：

```c++
Circle c1 = Circle(1.2, "red");
Circle c2 = Circle(3.4);
Circle c3 = Circle;
```

## 2.5 点(.)操作符

引用一个对象的成员，你需要：

1. 首先确定是哪个实例，然后
2. 使用点操作符来引用成员

同样的，假如我们有一个名为`Circle`的类，其中有两个数据成员和两个函数，我们已经创建了三个实例，分别为`c1`, `c2`, `c3`。

```c++
//创建实例
Circle c1(1.2, "blue");
Circle c2(3.4, "green");

//调用成员方法
cout << c1.getArea() << endl;
cout << c2.getArea() << endl;

//引用数据成员
c1.radius = 5.5;
c2.radius = 6.6;
```

## 2.6 数据成员（变量）

成员变量有一个变量名和变量类型，用以存放一个特定类型的值。成员变量也可以是一个特定类的实例。


## 2.7 成员方法

一个成员方法：

1. 从调用者接收参数
2. 执行定义好的操作
3. 返回结果给调用者

## 2.8 将它们合在一起：一个OOP的例子

![](/img/2018-02-13/OOP_Circle.png)

在这个例子中，我们会将所有代码放在一个源文件中`CircleAIO.cpp`

```c++
/*
 * The Circle class (All source code in one file) (CircleAIO.cpp)
 */


#include <iostream> // using IO functions
#include <cstring>  // using string

using namespace std;

class Circle {
private:
	double radius;		// Data member (Variable)
	string color;		// Data member (Variable)

public:
	// Constructor with default values for data members.
	Circle(double r = 1.0, string c = "red") {
		radius = r;
		color = c;
	}

	// Member function (Getter)
	double getRadius() {
		return radius;
	}

	// Member function (Getter)
	string getColor() {
		return color;
	}
	
	// Member function
	double getArea() {
		return radius * radius * 3.14;
	}
}; // need to end the class declaration with a semi-colon

// Test driver function
int main(int argc, char *argv[])
{
	Circle c1(1.2, "blue");	
	cout << "Radius=" << c1.getRadius() << " Area=" << c1.getArea()
		<< " Color=" << c1.getColor() << endl;

	Circle c2(3.4);
	cout << "Radius=" << c2.getRadius() << " Area=" << c2.getArea()
		<< " Color=" << c2.getColor() << endl;

	Circle c3;
	cout << "Radius=" << c3.getRadius() << " Area=" << c3.getArea()
		<< " Color=" << c3.getColor() << endl;
	return 0;
}
```

## 2.9 构造器

构造器是一个跟类名同名的特定方法。在上述的`Circle`类中，我们是这样定义构造器的：

```c++
// Constructor has the same name as the class
Circle(double r = 1.0, string c = "red") {
	radius = r;
	color = c;
}
```

构造器是用来构造和初始化数据成员的。创建一个类的新实例，你需要申明一个实例的标识符然后调用构造器：

```c++
Circle c1(1.2, "blue");
Circle c2(3.4);
Circle c3;
```

构造器和普通方法的区别在于下面几个方面：

- 构造器函数跟类同名
- 构造器没有返回值（或者说是返回`void`类型）。也就是说，构造器中允许缺省`return`语句。
- 构造器只能在初始化实例的时候被调用一次
- 构造器不能被继承

## 2.10 函数的默认值

在C++中，你可以给函数参数指定默认值：

```c++
/* Test function default arguments (TestFnDefault.cpp) */
#include <iostream>

using namespace std;

// Function prototype
int sum(int n1, int n2, int n3 = 0, int n4 = 0, int n5 = 0);

int main() {
	cout << sum(1, 1, 1, 1, 1) << endl;	// 5
	cout << sum(1, 1, 1, 1) << endl;	// 4
	cout << sum(1, 1, 1) << endl;		// 3
	cout << sum(1, 1) << endl;			// 2
	cout << sum(1) << endl;				// error: too few arguments
}

// Function definition
// The default values shell be specified in function prototype,
// not the function implementation.
int sum(int n1, int n2, int n3, int n4, int n5) {
	return n1 + n2 + n3 + n4 + n5;
}
```

## 2.11 "public" vs . "private" 访问控制符

访问控制符用来控制成员变量和成员方法的可见性。

1. public：成员可见
2. private：成员只能在类中可见

## 2.12 封装

## 2.13 Getters 和 Setters

为了让外部访问到`private`修饰的成员变量，你需要提供get函数，通常命名为`getXxx()`。getter不必讲数据原样暴露出来，
它可以对数据视图做一些限制。Getters不能修改成员属性。

为了让外部能够修改被`private`修饰的成员变量，你需要提供set函数，通常命名为`setXxx()`，setter函数需要保证数据的合法性，
然后将其转换成类内部展示的形式。


## 2.14 "this"关键字

我们可以使用"this"关键字在当前类内部引用当前实例。

"this"的一个主要作用就是解决函数参数名和成员变量名冲突的问题.

```c++
class Circle {
private:
	double radius;

public:
	void setRadius(double radius) {
		this->radius = radius;
	}
}
```

## 2.15 "const"成员函数


