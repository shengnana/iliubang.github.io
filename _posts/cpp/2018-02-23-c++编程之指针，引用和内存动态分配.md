---
layout: post
title: c++编程之指针，引用和内存动态分配 
author: 刘邦
excerpt: "c++编程之指针，引用和内存动态分配"
date: "2018-02-23"
catalog: true
tags: [c++]
category: c++
comments: true
---

原文地址:[https://www.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html](https://www.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html)

指针，引用和动态分配内存是C/C++语言中最强大的特性，这些特性使得程序员能够直接操作计算机中最关键和珍贵的记忆体，从而达到最大性能和高效的使用。
然而指针也是一把双刃剑，它也是C/C++编程语言中最复杂和最难的特性。

指针之所以这么强大，是因为它允许你通过地址来访问和操作对应记忆体中存储的内容。但是指针也很难被驾驭，使用好的话确实能够大大提升性能，而用的
不好的话，也会导致很多问题，例如著名的内存泄漏和缓冲区溢出，这些bug能导致系统发生紊乱。一些新的编程语言（例如Java和C#），将指针从它的语法
中去掉，通过提供自动内存管理的方式避免使用指针导致的许多问题。

虽然你在编写C/C++代码的时候可以不使用指针，但是在学习C/C++的时候很难不提及指针。指针也许不是为新手和笨蛋而设计的。


# 1. 指针变量

计算机记忆体位置有一个地址，对应地址处保存数据。记忆体地址通常是一个数字（一般用十六进制表示），这个数字很难被程序员直接使用。通常一个地址位置
的容量是8-bit（也就是1-byte），里面可以存储整数，实数，字符或者字符串，这完全取决于程序员如何解析。

为了减轻程序员使用数字地址和解析数据的负担，早期的编程语言（例如C语言）中产生了一种新的变量——这种变量是一个被命名了的变量的位置，它可以存储一个特定类型的值。
取代数字地址的是用名字（或者标识符）直接关联到确定的地址上，而且变量类型（如`int`, `double`, `char`）与之关联，从而简化了对数据的解析。

每个内存地址占8位（也就是1个字节），一个4个字节的`int`值需要4个内存位置。一个32位的系统通常使用32位的地址。同样的，存储这个32位的地址也需要4个内存位置。

下面的插图形象的描绘了计算机内存地址，内存中数据，变量名，变量类型以及变量值之间的关系。

![](/img/2018-02-23/MemoryAddressContent.png)

## 1.1 指针变量

指针变量（简称指针）基本上跟其他变量一样，都可以用来存放数据，但是跟普通变量不同的是，普通变量存储的是数值，而指针存放的是内存地址。

## 1.2 申明指针

指针在使用前必须先申明。申明指针的语法是在指针名前加上一个`*`符号。指针必须跟类型关联。

```cpp
type *ptr;
// or
type* ptr;
// or
type * ptr;
```

例如：

```cpp
int * iPtr;
double *dPtr;
```

需要注意的是，`*`必须放在指针变量名前面，一个`*`只作用于跟在它后面的指针变量名。`*`在申明语句中不是一个操作符，仅仅表明跟在它后门的变量是一个指针变量。

例如：

```cpp
int *p1, *p2, i;
int* p1, p2, i;
int * p1, * p2, i;
```

指针变量名的命名规则：用"p"或者"ptr"作为前缀或后缀。

## 1.3 使用取址操作符(&)初始化指针

当你申明一个指针的时候，它并没有被初始化。也就是说，它指向一个不确定的非法地址，这是很危险的。你需要通过给它赋值为一个合法地址来对它进行初始化，而要完成这一
操作，需要使用取址操作符(&)。

取址操作符(&)作用于变量，返回该变量的地址。例如，如果`number`是一个`int`类型的变量，那么`&number`返回的就是这个变量的地址。

```cpp
int number = 80;
int *pNumber;
pNumber = &number;

int *pAnother = &number;
```

![](/img/2018-02-23/PointerDeclaration.png)

如上图所示，`int`型变量`number`的起始地址是`0x22ccec`，其中存放了一个`int`值88。表达式`&number`返回该变量的地址，也就是`0x22ccec`，然后赋值给了指针变量`pNumber`。
取址操作符只能用在RHS(right hand side).

## 1.4 间接寻址或解引操作符(`*`)

间接寻址操作符（或解引操作符）(`*`)作用于指针变量，返回存放在指针指向地址处的数据。例如，如果`pNumber`是一个`int`型指针，`*pNumber`返回指针`pNumber`指向的`int`数值。

```c++
int number = 88;
int *pNumber = &number;
cout << pNumber << endl;
cout << *pNumber << endl;
*pNumber = 99;
cout << *pNumber << endl;
cout << number << endl;
```

需要注意的是`pNumber`存放的是内存地址，也就是说`*pNumber`是指指针存放的地址处存放的数值，或者也可以说是指针指向的数值。

正如前面插图描绘的，变量直接引用数值，而指针通过内存地址间接引用数值。而这种间接引用被称为间接寻址或解引。

解引操作符既能被用于RHS(`temp = *pNumber`)，也可以被用于LHS(`*pNumber = 99`).

注意：`*`在申明语句中和表达式中有不同的含义，在申明语句中，它表示跟在它后门的变量是一个指针变量，而在表达式中，它指的是指针指向的数值。

## 1.5 指针也有类型

指针在申明的时候就要确定它所关联的类型。指针只能保存它所申明的类型的变量的地址。

```c++
int i = 88;
double d = 55.66;
int *iPtr = &i;
double *dPtr = &d;

iPtr = &d; // ERROR, cannot hold address of different type
dPtr = &i; // ERROR
iPtr = i;  // ERROR, pointer holds address of an int , NOT int value

int j = 99;
iPtr = &j; // You can change the address stored in a pointer.
```

示例

```c++
#include <iostream>

using namespace std;

int main(int argc, char *argv[])
{
	int number = 88;
	int *pNumber;
	pNumber = &number;

	cout << pNumber << endl;
	cout << &number << endl;
	cout << *pNumber << endl;
	cout << number << endl;

	*pNumber = 99;
	cout << pNumber << endl;
	cout << &number << endl;
	cout << *pNumber << endl;
	cout << number << endl;

	cout << &pNumber << endl;
	return 0;
}
```

运行结果为：

```
→ g++ test_pointer.cpp  && ./a.out
0x7ffee123c04c
0x7ffee123c04c
88
88
0x7ffee123c04c
0x7ffee123c04c
99
99
0x7ffee123c040
```

注意：你得到的地址可能跟我得到的不同，操作系统将程序加载到可用的空闲地址，而不是固定的地址。

## 1.7 空指针

你可以将指针初始化为`0`或者`NULL`，那么它将指向空，我们称之为空指针。解引空指针会引发`STATUS_ACCESS_VIOLATION`异常。

```c++
int *iPtr = 0;
cout << *iPtr << endl; // ERROR! STATUS_ACCESS_VIOLATION exception

int *p = NULL;
```

# 2. 引用变量

C++增加了一种叫做引用变量（或者简称为引用）的特性。一个引用就是一个已有变量的别名。例如，假设给`paul`起了个引用（别名）`peter`，那么`peter`和`paul`都指的是同一个人。



