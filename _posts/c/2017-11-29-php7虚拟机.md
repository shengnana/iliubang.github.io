---
layout: post
title: php7虚拟机
subtitle: 
author: 刘邦
weather: sunny
catalog: true
tags: [c,php]
category: c
use_math: true
---


写这篇文章的目的是基于php7，阐述Zend Virtual Machine的内部实现。这不是一篇综合描述，我将尽可能地覆盖到所有重要的部分和细节。

本文的描述对象是php7.2版本，但是几乎所有的特性都已经应用在了php7.0/7.1中了。然而，它们同php5.x系列VM的不同之处同样也很重要，我会很有耐心的同步描述。

这篇文章主要集中在指令集的层面看待事物，只有在末尾的少量篇幅会涉及到C语言层面实现VM的细节。但是在这之前，我想先提供一些实现VM的主要代码文件：

- [zend_vm_def.h](https://github.com/php/php-src/blob/master/Zend/zend_vm_def.h): VM 定义文件
- [zend_vm_execute.h](https://github.com/php/php-src/blob/master/Zend/zend_vm_execute.h): 生成的VM
- [zend_vm_gen.php](https://github.com/php/php-src/blob/master/Zend/zend_vm_gen.php): VM生成脚本
- [zend_execute.c](https://github.com/php/php-src/blob/master/Zend/zend_execute.c): 大多数直接支持的代码

## Opcodes

首先我们来聊聊opcode。"Opcode"是用来表述整个VM指令集（包括操作数）的，但是也可能仅仅指的是“真实的”操作码，这些操作码是一个很小的整数用来区分不同的指令类型。其具体的含义需要结合代码的上下文才能清楚。在程式码中，指令通常被称作"oplines"。 

下面是`zend_op`的结构

```c
struct _zend_op {
    const void *handler;
    znode_op op1;
    znode_op op2;
    znode_op result;
    uint32_t extended_value;
    uint32_t lineno;
    zend_uchar opcode;
    zend_uchar op1_type;
    zend_uchar op2_type;
    zend_uchar result_type;
};
```

如此看来，opcodes本质上就是一个“三地址码”格式的指令。有一个`opcode`代表指令的类型，有两个输入操作数`op1`和`op2`和一个输出操作数`result`。

并不是所有的指令都一定会使用全部的操作数。`ADD`指令（表示`+`操作符）会使用全部的操作数，`BOOL_NOT`指令（表示`!`操作符）只会用到`op1`和`result`。而`ECHO`
指令只会用到`op1`。还有一些指令既可能用到也可能不会使用操作数，例如`DO_FCALL`可能会也可能不会有结果操作数，这取决于调用的函数是否有返回值。还有一些指令
可能会需要超过２个输入操作数，在这种情况下，将会使用一个虚设的指令(`OP_DATA`)来传递额外的操作数。

紧挨三个标准操作数后面的是一个额外的数字字段`extended_value`，它可以用来存放一些额外的指令标识，例如`CAST`指令，它需要保存将要转换的目标类型。

每一个操作数都有一个类型，分别存放在`op1_type`，`op2_type`，`result_type`当中。所有可能的类型有`IS_UNUSED`，`IS_CONST`，`IS_TMPVAR`，`IS_VAR`，`IS_CV`。
后三种类型用来指定变量操作数（有三种不同的VM变量类型），`IS_COUNT`表示一个常量操作数，而`IS_UNUSED`表示一个操作数是否被使用，或者操作数被用作一个32位数字
类型（一个立即数，汇编中的术语）。例如Jump指令会将跳转的目标存放在一个`UNUSED`操作数中。

## 输出Opcode

接下来，我将会频繁展示一些php示例代码生成的opcode序列。目前有三种方式来打印出opcode.

```shell
# Opcache, since PHP 7.1
php -d opcache.opt_debug_level=0x10000 test.php

# phpdbg, since PHP 5.6
phpdbg -p* test.php

# vld, third-party extension
php -d vld.active=1 test.php
```

上述方法中，opcache输出的opcode质量更高。文章中使用的opcode是基于opcache输出的，其中有些做了极少量语法的调整。魔法数字`0x10000`表示“优化前”，使用这个级别
输出的是php编译器生成的opcodes，`0x20000`会输出优化过的opcodes。Opcache还能生成更多的信息，例如使用`0x40000`将会生成`CFG`(Control flow graph)，使用`0x200000`将会生成类型和范围推断的SSA形式，但是这些已经超出了本文的范围，所以最原始的opcode输出才是最满足我们需求的。

## 变量类型

在开发PHP虚拟机的时候有一个非常重要的地方需要理解，那就是VM使用三种不同的变量类型。在PHP5中，`TMPVAR`，`VAR`和`CV`在虚拟机栈中不仅含义上有着明显的区别，
访问方式都不相同。但是到了PHP7，它们公用一套存储机制使得它们变得很相似。而然，有一些重要的不同之处在于它们能够存储数据和它们的语义。

`CV`是`compiled variable`的简写，代表的是真正的PHP变量。如果一个函数使用变量`$a`，那么将会是一个`CV`类型的操作数表示`$a`。CVs也可以有`UNDEF`类型，用以表示没有定义的变量。如果一个指令使用了UNDEF CV，（在大多数情况下）将会抛出一个众所周知的“undefined variable”警告。在function entry中，所有非参数CVs都会被初始化为UNDEF。

CVs不是被指令消费的，例如一个指令`ADD $a, $b`不会销毁存放在CVs`$a`，`$b`中的数据，取而代之的是CVs在作用域结束的时候一起被销毁。也就是说，所有CVs“存活”于
整个函数期间，这里的“存活”指的是其包含一个合法的数值（并非存活于数据流层面）。

`TMPVARs`和`VARs`从某种意义上说其实就是虚拟机的临时变量。他们通常产生于作为一些操作的结果操作数。例如`$a = $b + $c + $d`将会生成一个如下所示的opcode的序列

```php
T0 = ADD $b, $c
T1 = ADD t0, $d
ASSIGN $a, T1
```

`TMP/VARs`总是在使用前被定义，所以不能持有`UNDEF`类型。不同于`CVs`，它们的值是被指令直接消费的。在上面的例子中，第二个ADD会销毁T0操作数中的值，至此以后
T0将不能再被使用。同样的，ASSIGN将会消费T1中的数值，然后并释放掉。





