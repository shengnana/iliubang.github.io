---
layout: post
title: php7虚拟机
subtitle: 
author: 刘邦
weather: sunny
catalog: true
tags: [c,php]
category: c
use_math: true
---


写这篇文章的目的是基于php7，阐述Zend Virtual Machine的内部实现。这不是一篇综合描述，我将尽可能地覆盖到所有重要的部分和细节。

本文的描述对象是php7.2版本，但是几乎所有的特性都已经应用在了php7.0/7.1中了。然而，它们同php5.x系列VM的不同之处同样也很重要，我会很有耐心的同步描述。

这篇文章主要集中在指令集的层面看待事物，只有在末尾的少量篇幅会涉及到C语言层面实现VM的细节。但是在这之前，我想先提供一些实现VM的主要代码文件：

- [zend_vm_def.h](https://github.com/php/php-src/blob/master/Zend/zend_vm_def.h): VM 定义文件
- [zend_vm_execute.h](https://github.com/php/php-src/blob/master/Zend/zend_vm_execute.h): 生成的VM
- [zend_vm_gen.php](https://github.com/php/php-src/blob/master/Zend/zend_vm_gen.php): VM生成脚本
- [zend_execute.c](https://github.com/php/php-src/blob/master/Zend/zend_execute.c): 大多数直接支持的代码

## Opcodes

首先我们来聊聊opcode。"Opcode"是用来表述整个VM指令集（包括操作数）的，但是也可能仅仅指的是“真实的”操作码，这些操作码是一个很小的整数用来区分不同的指令类型。其具体的含义需要结合代码的上下文才能清楚。在程式码中，指令通常被称作"oplines"。 

下面是`zend_op`的结构

```c
struct _zend_op {
    const void *handler;
    znode_op op1;
    znode_op op2;
    znode_op result;
    uint32_t extended_value;
    uint32_t lineno;
    zend_uchar opcode;
    zend_uchar op1_type;
    zend_uchar op2_type;
    zend_uchar result_type;
};
```

如此看来，opcodes本质上就是一个“三地址码”格式的指令。有一个`opcode`代表指令的类型，有两个输入操作数`op1`和`op2`和一个输出操作数`result`。

并不是所有的指令都一定会使用全部的操作数。`ADD`指令（表示`+`操作符）会使用全部的操作数，`BOOL_NOT`指令（表示`!`操作符）只会用到`op1`和`result`。而`ECHO`
指令只会用到`op1`。还有一些指令既可能用到也可能不会使用操作数，例如`DO_FCALL`可能会也可能不会有结果操作数，这取决于调用的函数是否有返回值。还有一些指令
可能会需要超过２个输入操作数，在这种情况下，将会使用一个虚设的指令(`OP_DATA`)来传递额外的操作数。

紧挨三个标准操作数后面的是一个额外的数字字段`extended_value`，它可以用来存放一些额外的指令标识，例如`CAST`指令，它需要保存将要转换的目标类型。

每一个操作数都有一个类型，分别存放在`op1_type`，`op2_type`，`result_type`当中。所有可能的类型有`IS_UNUSED`，`IS_CONST`，`IS_TMPVAR`，`IS_VAR`，`IS_CV`。
后三种类型用来指定变量操作数（有三种不同的VM变量类型），`IS_COUNT`表示一个常量操作数，而`IS_UNUSED`表示一个操作数是否被使用，或者操作数被用作一个32位数字
类型（一个立即数，汇编中的术语）。例如Jump指令会将跳转的目标存放在一个`UNUSED`操作数中。

## 输出Opcode

接下来，我将会频繁展示一些php示例代码生成的opcode序列。目前有三种方式来打印出opcode.

```shell
# Opcache, since PHP 7.1
php -d opcache.opt_debug_level=0x10000 test.php

# phpdbg, since PHP 5.6
phpdbg -p* test.php

# vld, third-party extension
php -d vld.active=1 test.php
```

上述方法中，opcache输出的opcode质量更高。文章中使用的opcode是基于opcache输出的，其中有些做了极少量语法的调整。魔法数字`0x10000`表示“优化前”，使用这个级别
输出的是php编译器生成的opcodes，`0x20000`会输出优化过的opcodes。Opcache还能生成更多的信息，例如使用`0x40000`将会生成`CFG`(Control flow graph)，使用`0x200000`将会生成类型和范围推断的SSA形式，但是这些已经超出了本文的范围，所以最原始的opcode输出才是最满足我们需求的。

## 变量类型

在开发PHP虚拟机的时候有一个非常重要的地方需要理解，那就是VM使用三种不同的变量类型。在PHP5中，`TMPVAR`，`VAR`和`CV`在虚拟机栈中不仅含义上有着明显的区别，
访问方式都不相同。但是到了PHP7，它们公用一套存储机制使得它们变得很相似。而然，有一些重要的不同之处在于它们能够存储数据和它们的语义。

`CV`是`compiled variable`的简写，代表的是真正的PHP变量。如果一个函数使用变量`$a`，那么将会是一个`CV`类型的操作数表示`$a`。CVs也可以有`UNDEF`类型，用以表示没有定义的变量。如果一个指令使用了UNDEF CV，（在大多数情况下）将会抛出一个众所周知的“undefined variable”警告。在function entry中，所有非参数CVs都会被初始化为UNDEF。

CVs不是被指令消费的，例如一个指令`ADD $a, $b`不会销毁存放在CVs`$a`，`$b`中的数据，取而代之的是CVs在作用域结束的时候一起被销毁。也就是说，所有CVs“存活”于
整个函数期间，这里的“存活”指的是其包含一个合法的数值（并非存活于数据流层面）。

`TMPVARs`和`VARs`从某种意义上说其实就是虚拟机的临时变量。他们通常产生于作为一些操作的结果操作数。例如`$a = $b + $c + $d`将会生成一个如下所示的opcode的序列

```php
T0 = ADD $b, $c
T1 = ADD t0, $d
ASSIGN $a, T1
```

`TMP/VARs`总是在使用前被定义，所以不能持有`UNDEF`类型。不同于`CVs`，它们的值是被指令直接消费的。在上面的例子中，第二个ADD会销毁T0操作数中的值，至此以后
T0将不能再被使用。同样的，ASSIGN将会消费T1中的数值，然后并释放掉。

上述表明`TMP/VARs`通常都很短命。在多数情况下，临时变量仅仅存活于单个指令空间。在这个短暂的存活间隔之外，临时变量的值就是垃圾数据。
那么TMP和VAR的区别到底是什么呢？其实区别并不多，其差异继承自PHP5，在PHP5中，TMPs是存放在虚拟机栈中的，VMRs是存放在堆中的。而PHP7中的所有变量都是存放在栈
当中的。因此，至今TMPs和VARs的主要区别是只有后者允许包含`REFERENCEs`。此外，VARSs也能够存放两种特殊类型的数据，一个是namely class entries，另一个是INDIRECT values。后者也通常被用来处理非普通的赋值操作。

下表总结了三种数据类型的主要区别:

```
       | UNDEF | REF | INDIRECT | Consumed? | Named? |
-------|-------|-----|----------|-----------|--------|
CV     |  yes  | yes |    no    |     no    |  yes   |
TMPVAR |   no  |  no |    no    |    yes    |   no   |
VAR    |   no  | yes |   yes    |    yes    |   no   |
```

## Op arrays

所有的PHP函数都代表了一个拥有相同`zend_function`header的结构体。"Function"在这里被理解的很宽泛，包括了真实函数的所有一切，从方法到独立的伪代码，到evel
代码。
用户层的函数使用`zend_op_array`结构体。它有超过30个成员，所以这里从一个简化版开始研究：

```c
struct _zend_op_array {
    /* Common zend_function header here */

    /* ... */
    uint32_t last;
    zend_op *opcodes;
    int last_var;
    uint32_t T;
    zend_string **vars;
    /* ... */
    int last_literal;
    zval *literals;
    /* ... */
};
```

这里边最重要的部分当然是`opcodes`了，它是一个opcodes（指令）的数组。`last`表示opcode数组中元素的个数。说到这里你也许会感到非常的疑惑，`last`看起来像是
最后一个opcode的索引，然而它真的是opcodes的个数（比最后一个opcode的索引值大１）。同样的规则适用于其他以`last_`开头的字段。

`last_var`是CVs的数量，`T`表示TMPs和VARs的数量（在大多数情况下，我们并没有对它们做明显的区分）。`vars`是一个CVs的名字数组。`literals`是用于存放代码中字面量的值的数组，这个数组会被`CONST`操作数引用。根据ABI(application binary interface)，每一个`CONST`操作数要么存储一个字面量表的指针，要么存储一个相对于字面量表的起始位置的偏移量。

关于op array结构还有很多内容，将会在后边描述。

## 栈帧布局

不考虑一些executor globals(EG)，所有的执行状态都是存储在虚拟机栈中的。VM栈每页256KB，页与页通过链表连接起来。在每个函数调用中，会在VM栈中分配一个新的栈帧，它们的布局如下：

```
+----------------------------------------+
| zend_execute_data                      |
+----------------------------------------+
| VAR[0]                =         ARG[1] | arguments
| ...                                    |
| VAR[num_args-1]       =         ARG[N] |
| VAR[num_args]         =   CV[num_args] | remaining CVs
| ...                                    |
| VAR[last_var-1]       = CV[last_var-1] |
| VAR[last_var]         =         TMP[0] | TMP/VARs
| ...                                    |
| VAR[last_var+T-1]     =         TMP[T] |
| ARG[N+1] (extra_args)                  | extra arguments
| ...                                    |
+----------------------------------------+
```

栈帧以一个`zend_execute_data`结构开始，后边跟着一个存放变量的数组。数组中的每个位置存放的数据都是一样的（简单的zval数值），但是它们却有着不同的用途。第一个`last_var`之前存放的都是CVs，第一个`num_args`之前存放的是函数参数。紧挨着CV后边的是`T`槽，用以存放TMP/VARs。最后，如果有一些“额外的”参数的话会存放在栈帧的末尾，它们通常用来处理`func_get_args()`。

CV和TMP/VAR操作数在指令中会被编码成相对于栈帧起始位置的偏移量，因此访问一个确定的变量将变得非常容易，仅仅访问`execute_data`中的偏移位置。下面是`zend_execute_data`的结构：

```c
struct _zend_execute_data {
    const zend_op       *opline;
    zend_execute_data   *call;
    zval                *return_value;
    zend_function       *func;
    zval                 This;             /* this + call_info + num_args    */
    zend_class_entry    *called_scope;
    zend_execute_data   *prev_execute_data;
    zend_array          *symbol_table;
    void               **run_time_cache;   /* cache op_array->run_time_cache */
    zval                *literals;         /* cache op_array->literals       */
};
```

其中最重要的是，这个结构体中包含了一个`opline`字段，它代表当前执行的指令，`func`是当前执行的函数。此外：

- `return_value`是一个指向存放返回值变量的指针
- `This`就是`$this`对象，但是同时也编码了函数参数个数和一些调用的元数据标记存放在此zval中没有使用的空间里
- `called_scope`是`static::`指向的PHP代码作用域
- `prev_execute_data`指向前一个栈帧，以便当前函数执行完毕后返回到外层调用
- `symbol_table`是一个典型的没有使用的符号表，用于某些疯狂的人实际使用中会用到变量或相关特性
- `run_time_cache`缓存op array运行时缓存，用来防止指针通过间接寻址的方式来访问当前结构
- `literals`缓存op array字面量表，目的同上

## 函数调用(Function call)

在介绍execute_data结构的时候，我跳过了`call`字段，因为在介绍它之前还需要先了解函数调用是如何工作的。

所有调用都使用同一指令序列上的变量。一个`var_dump($1, $b)`在全局作用域中会被编译成下面的指令序列：

```
INIT_FCALL (2 args) "var_dump"
SEND_VAR $a
SEND_VAR $b
V0 = DO_ICALL   # or just DO_ICALL if retval unused
```

根据不同的调用类型，总共有８种不同类型的INIT指令。`INIT_FCALL`用于调用后立即释放的函数调用。同理根据不同的参数类型和函数类型，共有10种不同的SEND指令。DO_CALL指令只有区区4种，ICALL用于调用内部函数。

尽管特定的指令不同，但是整个流程却一直如此：INIT,SEND,DO。现在调用序列需要解决的主要问题是嵌套调用，它们编译后的指令形如以下：

```
# var_dump(foo($a), bar($b))
INIT_FCALL (2 args) "var_dump"
    INIT_FCALL (1 arg) "foo"
    SEND_VAR $a
    V0 = DO_UCALL
SEND_VAR V0
    INIT_FCALL (1 arg) "bar"
    SEND_VAR $b
    V1 = DO_UCALL
SEND_VAR V1
V2 = DO_ICALL
```

我使用缩进来区分哪个指令代表哪个调用。

INIT opcode将一个调用栈帧push到栈中，栈帧中包含了充足的空间来存放函数中的所有变量和已知数量的参数(如果涉及到参数解包，我们可能会得到更多参数)。这个调用栈帧伴随着函数调用被初始化，`$this`和`called_scope`（在上面情况下都是NULL，因为它们是调用后就释放的函数）。

一个新的栈帧的指针被存放在`execute_data->call`中，其中`execute_data`是调用函数的栈帧。下面我们将分析一个形如`EX(call)`的访问形式。特别地，新栈帧的`prev_execute_data`会被设置成旧的`EX(call)`。例如，对于`foo`的`INIT_FCALL`会把其`prev_execute_data`设置成`var_dump`的栈帧，如此以来，prev_execute_data在这种形式下构成了一个未完成调用的链表，从而形成了一个回溯链。

SEND opcode接下来将参数push到`EX(call)`的变量槽中。在这种情况下，参数都是连续的，而且也可能超出参数预设的存放区域到达CVs或TMPs区域，但是它们会在后边被修复。

接着DO_FCALL才是进行真正的调用。此时`EX(call)`变成当前执行的函数而`prev_execute_data`则重新指向外层调用函数。除此之外，调用过程也取决于被调用函数的类型。内部函数只需要执行一个handler函数，而用户层函数需要先初始化栈帧。初始化过程包含了对参数栈的修复。PHP允许向一个函数传递的参数超过预期参数个数。然而，只有被声明过的参数才会对应到CVs，超出的参数将会被写到记忆体中其他CVs和TMPs的位置，但是像这样的参数随后会被移动到TMPs后面的位置，最终的结果就是函数参数位于两个不连续的记忆体区块中。

这里需要清楚的是，用户端的函数调用不涉及到虚拟机级别的递归。它们只是从一个execute_data切换到另一个，但虚拟机在线性循环中继续运行。虚拟机级别的递归仅仅出现在内部函数中包含用户端回调的时候（例如：通过`array_map`）。这就是为什么在PHP中无限递归通常会导致内存限制或OOM错误，但是通过回调函数或魔术方法可能会引发栈溢出。

## 传送参数(Argument sending)

PHP使用大量不同的参数传递opcode，多亏了那些不幸的名字，让我们对它们的区别感到困惑。

SEND_VAL和SEND_VAR是最简单的两个，它们用来传递按值传递的参数。SEND_VAL用于CONST和TMP操作数，而SEND_VAR用于VARs和CVs的传递。

相反地，SEND_REF用来处理按引用传递的参数。因为只有变量才能按引用传递，所以此opcode只能接收VARs和CVs。

SEND_VAL_EX和SEND_VAR_EX是SEND_VAL和SEND_VAR的变种，用于不能确定参数到底是按值传递还是按引用传递的情况。这两个opcode会根据arginfo来检查参数的类型然后进行相应操作。大多数情况下，arginfo结构并没有使用，取而代之的是函数结构中的一个压缩的位向量。

接着是SEND_VAR_NO_REF_EX。不要视图从它的名字里去获取什么信息，因为它完全是一个谎言。这个opcode用于当传递一个不是真实变量，但是会返回一个不确定参数类型的VAR的时候。两个典型的例子就是将一个函数调用的结果作为参数传递，或者将赋值的结果作为参数传递。这些情况下需要一个单独的opcode主要有两个原因：其一，如果你试图将类似于赋值操作的表达式按引用传递，它会生成熟悉的"Only variables should be passed by reference"警告（如果使用SEND_VAR_EX的话，就会悄悄的允许）。其二，这个opcode可以处理我们想把一个返回引用类型数据类型函数的返回值传递给按引用传递的参数的情况(它不会抛出任何信息)。这个opcode的一个变种SEND_VAR_NO_REF是一个特殊的用来处理我们明确知道参数是一个引用类型的情况。

SEND_UNPACK和SEND_ARRAY这两个opcodes分别用来处理参数解包和内敛`call_user_func_array`调用。它们都能够将数组中的元素push到参数栈中，但是在处理细节上有一些不同（例如：unpacking支持遍历，而call_user_func_array不支持）。如果unpacking/cufa被使用，就有可能适当地去扩展栈帧的大小。通常，可以通过移动栈帧顶部指针来扩展。然而，如果达到了栈page的边界，就需要分配一个新的page，然后将整个调用栈帧拷贝到新的page当中（我们不能处理跨page的栈帧）

最后一个opcode是SEND_USER，它是用于内敛函数`call_user_func`调用。

至此我们还没有讨论过不同的变量查询模式，这里是一个不错的地方来介绍FUNC_ARG查询模式。思考形如`func($a[0][1][2])`的调用，我们不知道在编译时期传入的参数是按值传递还是按引用传递。这两个情况下的行为是不同的。如果是按值传递，而且`$a`之前为空，那么会产生一些"undefined index"警告。如果按引用传递，那么会悄悄的初始化嵌套数组。FUNC_ARG访问模式通过检查当前的`EX(call)`函数的arginfo来动态选择两种行为(R或W)中的一种，对于上面的例子，opcode序列如下：

```php
INIT_FCALL_BY_NAME "func"
V0 = FETCH_DIM_FUNC_ARG (arg 1) $a, 0
V1 = FETCH_DIM_FUNC_ARG (arg 1) V0, 1
V2 = FETCH_DIM_FUNC_ARG (arg 1) V1, 2
SEND_VAR_EX V2
DO_FCALL
```

## 查询模式(Fetch modes)

PHP虚拟机有四类用于查询的 opcodes:

```php
FETCH_*             // $_GET, $$var
FETCH_DIM_*         // $arr[0]
FETCH_OBJ_*         // $obj->prop
FETCH_STATIC_PROP_* // A::$prop 
```

如注释中说明的，基础的`FETCH_*`用来访问变量变量和超全局变量。这些fetch opcodes每一类又分6种：

```
_R
_RW
_W
_IS
_UNSET
_FUNC_ARG
```

我们已经知道`_FUNC_ARG`会根据函数是按值传递还是按引用传递来选择`_R`和`_W`模式。下面我们来举一些出现不同查询模式的例子：

```php
// $arr[0];
V2 = FETCH_DIM_R $arr int(0)
FREE V2

// $arr[0] = $val;
ASSIGN_DIM $arr int(0)
OP_DATA $val

// $arr[0] += 1;
ASSIGN_ADD (dim) $arr int(0)
OP_DATA int(1)

// isset($arr[0]);
T5 = ISSET_ISEMPTY_DIM_OBJ (isset) $arr int(0)
FREE T5

// unset($arr[0]);
UNSET_DIM $arr int(0)
```

不幸的是，实际上产生的唯一查询就是`FETCH_DIM_R`：其他的操作都是通过特定的opcodes处理的。注意到`ASSIGN_DIM`和`ASSIGN_ADD`都使用一个额外的`OP_DATA`，因为它们都需要超过2个操作数。之所以用到像`ASSIGN_DIM`这样的特殊opcodes而没有用到`FETCH_DIM_W`+`ASSIGN`的原因是这些操作可能会被覆盖，例如，通过一个对象实现`ArrayAccess::offsetSet()`的方式构成`ASSIGN_DIM`的情形。为了真正产生不同的fetch types，我们需要增加嵌套层级：

```php
// $arr[0][1];
V2 = FETCH_DIM_R $arr int(0)
V3 = FETCH_DIM_R V2 int(1)
FREE V3

// $arr[0][1] = $val;
V4 = FETCH_DIM_W $arr int(0)
ASSIGN_DIM V4 int(1)
OP_DATA $val

// $arr[0][1] += 1;
V6 = FETCH_DIM_RW $arr int(0)
ASSIGN_ADD (dim) V6 int(1)
OP_DATA int(1)

// isset($arr[0][1]);
V8 = FETCH_DIM_IS $arr int(0)
T9 = ISSET_ISEMPTY_DIM_OBJ (isset) V8 int(1)
FREE T9

// unset($arr[0][1]);
V10 = FETCH_DIM_UNSET $arr int(0)
UNSET_DIM V10 int(1)
```

这里我们看到，最外层的访问通过特定的opcodes，而嵌套的索引则使用特定模式的FETCHes。访问不存在的索引是否产生"undefined offset"警告和是否会对查询的数据执行写操作，对于不同的fetch modes来说也是不同的：

```php
      | Notice? | Write?
R     |  yes    |  no
W     |  no     |  yes
RW    |  yes    |  yes
IS    |  no     |  no
UNSET |  no     |  yes-ish
```

UNSET的情况有点特殊，它只会对存在的索引值进行写操作，而跳过没有定义的部分。而一个普通的write-fetch操作会先初始化没有定义的变量。

### Writes and memory safety

写查询模式会返回包含一个普通zval或者一个指向另一个zval的INDIRECT指针的VARs。当然，前面任何对该zval的改变都是不可见的，因为这个值只能通过虚拟机临时变量访问。尽管PHP禁止形如`[][0] = 42`这样的表达式，但是我们仍然需要处理类似于`call()[0] = 42`这种操作。这取决于`call()`是否返回一个数值还是一个数值的引用。

另个一个更加特殊的情形是查询返回一个INDIRECT，其中包含的指向一个记忆体的指针被修改了，例如hashtable数组中一个确定的位置，不行的是，这样的指针是很脆弱的，很容易被失效：任何对于该数组并发写操作都可能触发reallocation，留下一个迷途(dangling)指针，因此在创建INDIRECT值的地方和它被消费之间阻止用户代码执行是至关重要的。

考虑如下例子：

```php
$arr[a()][b()] = c();
```

将会产生如下opcode序列：

```php
INIT_FCALL_BY_NAME (0 args) "a"
V1 = DO_FCALL_BY_NAME
INIT_FCALL_BY_NAME (0 args) "b"
V3 = DO_FCALL_BY_NAME
INIT_FCALL_BY_NAME (0 args) "c"
V5 = DO_FCALL_BY_NAME
V2 = FETCH_DIM_W $arr V1
ASSIGN_DIM V2 V3
OP_DATA V5
```
