---
layout: post
title: php7虚拟机
subtitle: 
author: 刘邦
weather: sunny
catalog: true
tags: [c,php]
category: c
use_math: true
---


写这篇文章的目的是基于php7，阐述Zend Virtual Machine的内部实现。这不是一篇综合描述，我将尽可能地覆盖到所有重要的部分和细节。

本文的描述对象是php7.2版本，但是几乎所有的特性都已经应用在了php7.0/7.1中了。然而，它们同php5.x系列VM的不同之处同样也很重要，我会很有耐心的同步描述。

这篇文章主要集中在指令集的层面看待事物，只有在末尾的少量篇幅会涉及到C语言层面实现VM的细节。但是在这之前，我想先提供一些实现VM的主要代码文件：

- [zend_vm_def.h](https://github.com/php/php-src/blob/master/Zend/zend_vm_def.h): VM 定义文件
- [zend_vm_execute.h](https://github.com/php/php-src/blob/master/Zend/zend_vm_execute.h): 生成的VM
- [zend_vm_gen.php](https://github.com/php/php-src/blob/master/Zend/zend_vm_gen.php): VM生成脚本
- [zend_execute.c](https://github.com/php/php-src/blob/master/Zend/zend_execute.c): 大多数直接支持的代码

## Opcodes

首先我们来聊聊opcode。"Opcode"是用来表述整个VM指令集（包括操作数）的，但是也可能仅仅指的是“真实的”操作码，这些操作码是一个很小的整数用来区分不同的指令类型。其具体的含义需要结合代码的上下文才能清楚。在程式码中，指令通常被称作"oplines"。 

下面是`zend_op`的结构

```c
struct _zend_op {
    const void *handler;
    znode_op op1;
    znode_op op2;
    znode_op result;
    uint32_t extended_value;
    uint32_t lineno;
    zend_uchar opcode;
    zend_uchar op1_type;
    zend_uchar op2_type;
    zend_uchar result_type;
};
```

如此看来，opcodes本质上就是一个“三地址码”格式的指令。有一个`opcode`代表指令的类型，有两个输入操作数`op1`和`op2`和一个输出操作数`result`。

并不是所有的指令都一定会使用全部的操作数。`ADD`指令（表示`+`操作符）会使用全部的操作数，`BOOL_NOT`指令（表示`!`操作符）只会用到`op1`和`result`。而`ECHO`
指令只会用到`op1`。还有一些指令既可能用到也可能不会使用操作数，例如`DO_FCALL`可能会也可能不会有结果操作数，这取决于调用的函数是否有返回值。还有一些指令
可能会需要超过２个输入操作数，在这种情况下，将会使用一个虚设的指令(`OP_DATA`)来传递额外的操作数。

紧挨三个标准操作数后面的是一个额外的数字字段`extended_value`，它可以用来存放一些额外的指令标识，例如`CAST`指令，它需要保存将要转换的目标类型。

每一个操作数都有一个类型，分别存放在`op1_type`，`op2_type`，`result_type`当中。所有可能的类型有`IS_UNUSED`，`IS_CONST`，`IS_TMPVAR`，`IS_VAR`，`IS_CV`。
后三种类型用来指定变量操作数（有三种不同的VM变量类型），`IS_COUNT`表示一个常量操作数，而`IS_UNUSED`表示一个操作数是否被使用，或者操作数被用作一个32位数字
类型（一个立即数，汇编中的术语）。例如Jump指令会将跳转的目标存放在一个`UNUSED`操作数中。

## 输出Opcode

接下来，我将会频繁展示一些php示例代码生成的opcode序列。目前有三种方式来打印出opcode.

```shell
# Opcache, since PHP 7.1
php -d opcache.opt_debug_level=0x10000 test.php

# phpdbg, since PHP 5.6
phpdbg -p* test.php

# vld, third-party extension
php -d vld.active=1 test.php
```

上述方法中，opcache输出的opcode质量更高。文章中使用的opcode是基于opcache输出的，其中有些做了极少量语法的调整。魔法数字`0x10000`表示“优化前”，使用这个级别
输出的是php编译器生成的opcodes，`0x20000`会输出优化过的opcodes。Opcache还能生成更多的信息，例如使用`0x40000`将会生成`CFG`(Control flow graph)，使用`0x200000`将会生成类型和范围推断的SSA形式，但是这些已经超出了本文的范围，所以最原始的opcode输出才是最满足我们需求的。

## 变量类型

在开发PHP虚拟机的时候有一个非常重要的地方需要理解，那就是VM使用三种不同的变量类型。在PHP5中，`TMPVAR`，`VAR`和`CV`在虚拟机栈中不仅含义上有着明显的区别，
访问方式都不相同。但是到了PHP7，它们公用一套存储机制使得它们变得很相似。而然，有一些重要的不同之处在于它们能够存储数据和它们的语义。

`CV`是`compiled variable`的简写，代表的是真正的PHP变量。如果一个函数使用变量`$a`，那么将会是一个`CV`类型的操作数表示`$a`。CVs也可以有`UNDEF`类型，用以表示没有定义的变量。如果一个指令使用了UNDEF CV，（在大多数情况下）将会抛出一个众所周知的“undefined variable”警告。在function entry中，所有非参数CVs都会被初始化为UNDEF。

CVs不是被指令消费的，例如一个指令`ADD $a, $b`不会销毁存放在CVs`$a`，`$b`中的数据，取而代之的是CVs在作用域结束的时候一起被销毁。也就是说，所有CVs“存活”于
整个函数期间，这里的“存活”指的是其包含一个合法的数值（并非存活于数据流层面）。

`TMPVARs`和`VARs`从某种意义上说其实就是虚拟机的临时变量。他们通常产生于作为一些操作的结果操作数。例如`$a = $b + $c + $d`将会生成一个如下所示的opcode的序列

```php
T0 = ADD $b, $c
T1 = ADD t0, $d
ASSIGN $a, T1
```

`TMP/VARs`总是在使用前被定义，所以不能持有`UNDEF`类型。不同于`CVs`，它们的值是被指令直接消费的。在上面的例子中，第二个ADD会销毁T0操作数中的值，至此以后
T0将不能再被使用。同样的，ASSIGN将会消费T1中的数值，然后并释放掉。

上述表明`TMP/VARs`通常都很短命。在多数情况下，临时变量仅仅存活于单个指令空间。在这个短暂的存活间隔之外，临时变量的值就是垃圾数据。
那么TMP和VAR的区别到底是什么呢？其实区别并不多，其差异继承自PHP5，在PHP5中，TMPs是存放在虚拟机栈中的，VMRs是存放在堆中的。而PHP7中的所有变量都是存放在栈
当中的。因此，至今TMPs和VARs的主要区别是只有后者允许包含`REFERENCEs`。此外，VARSs也能够存放两种特殊类型的数据，一个是namely class entries，另一个是INDIRECT values。后者也通常被用来处理非普通的赋值操作。

下表总结了三种数据类型的主要区别:

```
       | UNDEF | REF | INDIRECT | Consumed? | Named? |
-------|-------|-----|----------|-----------|--------|
CV     |  yes  | yes |    no    |     no    |  yes   |
TMPVAR |   no  |  no |    no    |    yes    |   no   |
VAR    |   no  | yes |   yes    |    yes    |   no   |
```

## Op arrays

所有的PHP函数都代表了一个拥有相同`zend_function`header的结构体。"Function"在这里被理解的很宽泛，包括了真实函数的所有一切，从方法到独立的伪代码，到evel
代码。
用户层的函数使用`zend_op_array`结构体。它有超过30个成员，所以这里从一个简化版开始研究：

```c
struct _zend_op_array {
    /* Common zend_function header here */

    /* ... */
    uint32_t last;
    zend_op *opcodes;
    int last_var;
    uint32_t T;
    zend_string **vars;
    /* ... */
    int last_literal;
    zval *literals;
    /* ... */
};
```

这里边最重要的部分当然是`opcodes`了，它是一个opcodes（指令）的数组。`last`表示opcode数组中元素的个数。说到这里你也许会感到非常的疑惑，`last`看起来像是
最后一个opcode的索引，然而它真的是opcodes的个数（比最后一个opcode的索引值大１）。同样的规则适用于其他以`last_`开头的字段。

`last_var`是CVs的数量，`T`表示TMPs和VARs的数量（在大多数情况下，我们并没有对它们做明显的区分）。`vars`是一个CVs的名字数组。`literals`是用于存放代码中字面量的值的数组，这个数组会被`CONST`操作数引用。根据ABI(application binary interface)，每一个`CONST`操作数要么存储一个字面量表的指针，要么存储一个相对于字面量表的起始位置的偏移量。

关于op array结构还有很多内容，将会在后边描述。

## 栈帧布局

不考虑一些executor globals(EG)，所有的执行状态都是存储在虚拟机栈中的。VM栈每页256KB，页与页通过链表连接起来。在每个函数调用中，会在VM栈中分配一个新的栈帧，它们的布局如下：

```
+----------------------------------------+
| zend_execute_data                      |
+----------------------------------------+
| VAR[0]                =         ARG[1] | arguments
| ...                                    |
| VAR[num_args-1]       =         ARG[N] |
| VAR[num_args]         =   CV[num_args] | remaining CVs
| ...                                    |
| VAR[last_var-1]       = CV[last_var-1] |
| VAR[last_var]         =         TMP[0] | TMP/VARs
| ...                                    |
| VAR[last_var+T-1]     =         TMP[T] |
| ARG[N+1] (extra_args)                  | extra arguments
| ...                                    |
+----------------------------------------+
```

栈帧以一个`zend_execute_data`结构开始，后边跟着一个存放变量的数组。数组中的每个位置存放的数据都是一样的（简单的zval数值），但是它们却有着不同的用途。第一个`last_var`之前存放的都是CVs，第一个`num_args`之前存放的是函数参数。紧挨着CV后边的是`T`槽，用以存放TMP/VARs。最后，如果有一些“额外的”参数的话会存放在栈帧的末尾，它们通常用来处理`func_get_args()`。

CV和TMP/VAR操作数在指令中会被编码成相对于栈帧起始位置的偏移量，因此访问一个确定的变量将变得非常容易，仅仅访问`execute_data`中的偏移位置。下面是`zend_execute_data`的结构：

```c
struct _zend_execute_data {
    const zend_op       *opline;
    zend_execute_data   *call;
    zval                *return_value;
    zend_function       *func;
    zval                 This;             /* this + call_info + num_args    */
    zend_class_entry    *called_scope;
    zend_execute_data   *prev_execute_data;
    zend_array          *symbol_table;
    void               **run_time_cache;   /* cache op_array->run_time_cache */
    zval                *literals;         /* cache op_array->literals       */
};
```

其中最重要的是，这个结构体中包含了一个`opline`字段，它代表当前执行的指令，`func`是当前执行的函数。此外：

- `return_value`是一个指向存放返回值变量的指针
- `This`就是`$this`对象，但是同时也编码了函数参数个数和一些调用的元数据标记存放在此zval中没有使用的空间里
- `called_scope`是`static::`指向的PHP代码作用域
- `prev_execute_data`指向前一个栈帧，以便当前函数执行完毕后返回到外层调用
- `symbol_table`是一个典型的没有使用的符号表，用于某些疯狂的人实际使用中会用到变量或相关特性
- `run_time_cache`缓存op array运行时缓存，用来防止指针通过间接寻址的方式来访问当前结构
- `literals`缓存op array字面量表，目的同上

## 函数调用

在介绍execute_data结构的时候，我跳过了`call`字段，因为在介绍它之前还需要先了解函数调用是如何工作的。

所有调用都使用同一指令序列上的变量。一个`var_dump($1, $b)`在全局作用域中会被编译成下面的指令序列：

```
INIT_FCALL (2 args) "var_dump"
SEND_VAR $a
SEND_VAR $b
V0 = DO_ICALL   # or just DO_ICALL if retval unused
```

根据不同的调用类型，总共有８种不同类型的INIT指令。`INIT_FCALL`用于调用后立即释放的函数调用。同理根据不同的参数类型和函数类型，共有10种不同的SEND指令。DO_CALL指令只有区区4种，ICALL用于调用内部函数。

尽管特定的指令不同，但是整个流程却一直如此：INIT,SEND,DO。现在调用序列需要解决的主要问题是嵌套调用，它们编译后的指令形如以下：

```
# var_dump(foo($a), bar($b))
INIT_FCALL (2 args) "var_dump"
    INIT_FCALL (1 arg) "foo"
    SEND_VAR $a
    V0 = DO_UCALL
SEND_VAR V0
    INIT_FCALL (1 arg) "bar"
    SEND_VAR $b
    V1 = DO_UCALL
SEND_VAR V1
V2 = DO_ICALL
```

我使用缩进来区分哪个指令代表哪个调用。

INIT opcode将一个调用栈帧push到栈中，栈帧中包含了充足的空间来存放函数中的所有变量和已知数量的参数(如果涉及到参数解包，我们可能会得到更多参数)。这个调用栈帧伴随着函数调用被初始化，`$this`和`called_scope`（在上面情况下都是NULL，因为它们是调用后就释放的函数）。

一个新的栈帧的指针被存放在`execute_data->call`中，其中`execute_data`是调用函数的栈帧。下面我们将分析一个形如`EX(call)`的访问形式。特别地，新栈帧的`prev_execute_data`会被设置成旧的`EX(call)`。例如，对于`foo`的`INIT_FCALL`会把其`prev_execute_data`设置成`var_dump`的栈帧，如此以来，prev_execute_data在这种形式下构成了一个未完成调用的链表，从而形成了一个回溯链。

SEND opcode接下来将参数push到`EX(call)`的变量槽中。在这种情况下，参数都是连续的，而且也可能超出参数预设的存放区域到达CVs或TMPs区域，但是它们会在后边被修复。

接着DO_FCALL才是进行真正的调用。此时`EX(call)`变成当前执行的函数而`prev_execute_data`则重新指向外层调用函数。除此之外，调用过程也取决于被调用函数的类型。内部函数只需要执行一个handler函数，而用户层函数需要先初始化栈帧。初始化过程包含了对参数栈的修复。PHP允许向一个函数传递的参数超过预期参数个数。然而，只有被声明过的参数才会对应到CVs，超出的参数将会被写到记忆体中其他CVs和TMPs的位置，但是像这样的参数随后会被移动到TMPs后面的位置，最终的结果就是函数参数位于两个不连续的记忆体区块中。

这里需要清楚的是，用户端的函数调用不涉及到虚拟机级别的递归。它们只是从一个execute_data切换到另一个，但虚拟机在线性循环中继续运行。虚拟机级别的递归仅仅出现在内部函数中包含用户端回调的时候（例如：通过`array_map`）。这就是为什么在PHP中无限递归通常会导致内存限制或OOM错误，但是通过回调函数或魔术方法可能会引发栈溢出。

## 传送参数

PHP使用大量不同的参数传递opcode，多亏了那些不幸的名字，让我们对它们的区别感到困惑。

SEND_VAL和SEND_VAR是最简单的两个，它们用来传递按值传递的参数。SEND_VAL用于CONST和TMP操作数，而SEND_VAR用于VARs和CVs的传递。

相反地，SEND_REF用来处理按引用传递的参数。因为只有变量才能按引用传递，所以此opcode只能接收VARs和CVs。

SEND_VAL_EX和SEND_VAR_EX是SEND_VAL和SEND_VAR的变种，用于不能确定参数到底是按值传递还是按引用传递的情况。这两个opcode会根据arginfo来检查参数的类型然后进行相应操作。大多数情况下，arginfo结构并没有使用，取而代之的是函数结构中的一个压缩的位向量。

接着是SEND_VAR_NO_REF_EX。不要视图从它的名字里去获取什么信息，因为它完全是一个谎言。这个opcode用于当传递一个不是真实变量，但是会返回一个不确定参数类型的VAR的时候。两个典型的例子就是将一个函数调用的结果作为参数传递，或者将赋值的结果作为参数传递。这些情况下需要一个单独的opcode主要有两个原因：其一，如果你试图将类似于赋值操作的表达式按引用传递，它会生成熟悉的"Only variables should be passed by reference"警告（如果使用SEND_VAR_EX的话，就会悄悄的允许）。其二，
