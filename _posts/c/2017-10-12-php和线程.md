---
layout: post
title: php和线程
subtitle: 
author: 刘邦
weather: sunny
catalog: true
tags: [c,php]
category: c
use_math: true
---

## 前言

PHP和线程，单凭这简短的几个字，就足以写一本书。像往常一样，我们不会这么做，但是会给出一定程度上跟这个话题相关的信息与细节。让我们从一些人在谈论这个话题时通常感到的困惑开始，PHP不是一种线程语言，
PHP的内核没有使用线程，而且PHP天生也不允许用户层代码通过任何方式使用多线程作为并发机制。

因此PHP跟其他一些技术有很大的区别，例如Java。Java不仅自身使用了大量的线程，它还允许用户通过编程来是用线程。然而，PHP不适用线程是有它的原因的。

PHP内核没有使用线程，主要是为了简化开发。当你读到下一节的时候，你就会了解到线程并不是一个能使任何程序都能更快运行的魔法技术。是不是听起来很像是在推销不是吗？但是我们不是推销，而是谈论技术，而且
我们很清楚我们在说什么。因此PHP引擎目前没有使用多线程，也许将来会使用。但是使用多线程在编程上会引发很多问题，例如程序运行结果不是你所期待的等等。主要的困难是跨平坦的多线程编程，其次就是资源共享和
锁的管理，再次就是并不是所有的程序都能够被转化成多线程程序。PHP的设计主要在2000前后，在那个时候，多线程编程并不是很广泛和成熟，PHP引擎开发工程师决定创造一个完全没有线程的单片机引擎（当然他们也没有
足够的能力去驾驭一个稳定的跨平台的多线程引擎）。

PHP用户层代码也不允许使用线程，因为那不是PHP期待你的代码运行的方式。PHP是一个"发送并忘记(fire-and-forget)"型的语言，你应该尽可能快的处理完请求，然后释放，然后接着处理下一个请求。PHP被设计作为一种
胶水语言：你不用处理可能使用到线程的复杂任务，而是访问快速而且已经准备好的资源，将它们粘合到一起，然后再返回给用户。通过PHP，无论什么可能花费比通常时间多的时间的任务，都不能用PHP来处理。这就是为什么
在PHP中我们通常使用基于消息队列的系统(Gearman, AMQP, ActiveMQ 等等)来异步处理一些耗时任务。正如Unix看待事物的方式：“开发小而完备的工具，然后将他们连接在一起”。因此PHP的设计不是允许大规模的并行，而是
其他专门的技术--是用正确的工具来解决特定的问题。

## 线程的简介

让我们来快速的介绍下线程。注意，我们不会阐述太多细节的东西，对于你想深入了解关于线程的任何细节，都可以在相关书籍和站点上找到。

线程是进程中的轻量的事务处理单元，注意，一个进程可以产生多个线程，一个线程必须有且只能属于一个进程。进程是操作系统中的基本工作处理单元。在多CPU的机器上，不同的CPU将会平行工作，这样对于计算能力的提升会
有很大的好处。如果进程A和B都准备被执行，而且两个CPU（或者两个CPU核心）也都有空闲的负载，那么进程A和B将会同时被执行。因此，计算机将能高效的在一个单位时间内同时进行多个运算，我们称之为“并行”(parallelism)。

进程

![进程](/img/2017-10-13/up.png)

线程

![线程](/img/2017-10-13/thread_structure.png)

进程和线程的关系
![进程和线程的关系](/img/2017-10-13/process_thread.gif)

线程不是进程，线程是进程中的执行单元。也就是说，一个进程可以将它的工作划分成多个小的任务，使他们同时执行。例如：进程A和进程B都能够创造线程，分别为A1,A2,B1,B2，如果计算机有多个CPU（例如8个），那么A1, A2, B1, B2将会在同一个时帧运行。

> 使用线程，程序员可以决定将进程任务划分成多个小的任务，使得他们能同时执行

线程的执行跟进程几乎完全一样：他们都拥有一个状态，内核线程调度程序通过这个状态来管理它们。

![](/img/2017-10-13/threads_lifetime.gif)

线程比进程更加轻量级，线程只需要一个栈和一些寄存器，而进程则需要更多的条件(内核虚拟机，堆，一些信号信息，一些文件描述符信息，一些锁信息等等)。

进程的内存是由内核和内存管理单元管理，而线程的内存是由程序员自己和一些线程库来管理。

## 线程的内存布局

正如我们了解的，线程拥有独立的栈，也就是说，线程访问有个函数中声明的变量时，他们访问的是他们持有的该变量的拷贝。但是我们不能用同样描述来说明进程的堆：堆在线程间是共享的，通常存放全局变量和文件描述符。
这样做有利也有弊。如果你只是读取一个全局的内存，你只需要在一个恰当的时机读取（例如在线程X之后，线程Y之前），如果你想要去写，那么你必须保证多个线程不能在同一时刻去写同一个内存空间：这样会破坏那个内存区域
让记忆体处于不可预知的状态；这种情况我们就称之为“竞争条件”，同时这也是线程编程背后所面临的主要挑战。

对于并发访问情况的发生，你需要在你的代码中加入一些诸如可重入性和同步机制的编程技术，可重入性用来防止并发，而同步则主要是保证并发按照可预测的方式进行。

拥有了一个很大的共享内存，就有必要去同步公共空间的访问，常用的技术有信号(semaphores)灯和互斥器(mutexes)。它们都是基于锁的概念，如果一个资源被锁定，同时有一个线程尝试访问，那么这个线程就会被阻塞，直到共享资源可以被访问。
这就是为什么使用线程并不一定就意味着你的程序能跑的更快。如果你不能有效的划分任务，或者不能有效的管理锁，程序将会比不用线程的单进程执行任务耗费更多的时间：因为线程总是在相互等待。

如果你没有熟练使用过线程的话，使用起来确实很复杂。你需要花很多时间去练习，而且会面临很多问题，如果你漏掉了一点点细节，那么你的整个程序可能在你面前崩溃掉。调试线程程序比调试非线程程序要困难的多，假如我们正在讨论的是成百上千个线程运行到进程中的真实用例，那么你将会很快迷失自己，陷入困难之中。

由于前面所述的那种共享内存的方式不是我们想要的，于是出现了Thread Local Storage(TLS)。TLS的主要原理是全局数据被线程持有，而且不能共享给其他线程，它们是一个代表全局状态的内存区域，但是对于线程而言是私有的。
要实现LTS，在线程被创建的时候，就要申请一些进程堆内存，线程库提供一个key，将该key关联到这块存储区域。每次访问这块属于特殊线程的区域，都需要使用这个特定的key来解锁才行。线程被销毁的时候，需要同时释放这块堆内存。

## Thread libraries

正如你的猜想，操作线程需要操作系统内核的帮助。在90年代中期，线程出现在操作系统中，又过了很长的时间，才逐渐成熟。但是依然存在跨平台的问题，尤其是windows和unix这两大对立阵营，他们采用了不同的线程模型和不同的线程库。如今，类unix系统中使用的是**pthread**（也同时存在一些其他的thread libraries）。Pthread代表的是"Posix threads"，这是一个可以追溯到1995年的POSIX规范的实现。因此，如果你想在你的程序中使用线程，你需要通过gcc的`-lpthread`开关开连接libpthread到你的程序。同时libpthread是一个用c语言编写的开源程式库，它有自己独立的版本控制和管理。

所以，通常情况下，在类unix系统中，我们使用**pthread**来进行多线程编程。需要注意的是，pthread允许并发，但是是否平行，这个取决于操作系统和计算机本身。并发是多个线程运行在同一个CPU执行序，平行是多个线程在同一时刻运行在不同的CPU上。

并发：

![并发](/img/2017-10-13/threads_concurrency.png)

平行：

![平行](/img/2017-10-13/threads_parallelism.png)

## PHP和多线程

让我们先回顾一下：

- PHP不是一个多线程的语言：PHP引擎不是通过管理线程来实现其并发机制。
- PHP不提供用户端操作线程的的方法：你不能通过原生PHP语言来直接操作线程。有一个由PHP核心开发人员Joe Watkins开发的PHP扩展：ext/pthread提供了操作线程的方法，虽然这是一个非常棒的扩展库，但是我个人还是不推荐如此使用PHP，毕竟对于多线程编程，PHP并不是合适的语言，比如我就会选择C或者Java。

那么，谈论PHP和多线程有什么意义呢？

## PHP是如何处理请求的

这里说的其实是PHP是如何处理HTTP请求的。为了在同一时间内服务多个客户端，一个web伺服器程式需要一些并发（或者平行）机制。你不能因为响应一个客户端而阻塞其他所有的请求不是吗？如此以来，伺服器程式通常的做法是使用多进程，或多线程去响应客户端。从历史的角度来看，在unix上，使用的是多进程模型。因为进程是unix的基础，从unix诞生的时候起，进程就诞生了，而且拥有创建、销毁、和同步的能力。在unix环境中，多个PHP服务多个客户端，但是每一个PHP在一个独立的进程中运行。

如果你还记得前言中介绍的，在这种情况下，PHP代码中不需要做任何额外的事情：进程间是彼此隔离的，进程A处理请求A中的数据，不会影响到进程B处理请求B中的数据，而这正是我们想要的。

使用这种模型的包括`php-fpm`和Apache的`mpm_prefork`，通常，在98%的情形下你是用的是二者中的其中一种架构。但是，到了windows环境下或者在那些使用线程的unix系统中，事情将会变得复杂。windows毫无质疑地是一个很优秀的操作系统，但是它有一个弊端就是它的代码不是公开的。不过幸运的是关于它内部引擎是如何工作的原理能够在互联网和一些书籍上找到，而且微软工程师也分享了很多关于windows核心的相关知识。在处理并发和平行的问题上，windows
选择了不同于unix的道路。windows高度依赖线程，事实上，在windows上创建一个进程的代价是很大的以至于你通常不会这么做。在windows系统中，你每时每刻都在使用线程。windows中的线程也比unix中强大很多。因此当你在windows上运行PHP的时候，伺服器程序（例如IIS，Apache，FooBarBaz）会使用多线程处理不同的客户端，而不是进程。也就是说，在这样的环境下，PHP将会运行在线程中，而且PHP要额外的小心线程的规则：它必须是线程安全的。

PHP必须是线程安全的，也就是说它必须能够控制不是由它自身创建的并发性，而且必须能够。聪明的你也许已经想到了，要解决这个问题，PHP就要寻找一种方法，能够防止其自身访问自己的全局变量。

于是就有了一个叫做**Zend Thread Safety**(ZTS)的模块，用以实现线程安全性。

## Zend Thread Safety 的内部细节

开启ZTS可以通过使用`--enable-maintainer-zts`编译开关。通常情况下，你不需要打开此开关，除非是运行在windows系统中，或者是你需要使用一些扩展需要引擎是线程安全的时候。
