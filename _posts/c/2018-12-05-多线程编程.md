---
layout: post
title: 多线程编程
author: 刘邦
excerpt: "POSIX threads tutorial"
catalog: true
tags: [c]
category: c
comments: true
---

原文地址:[http://www.cs.kent.edu/~ruttan/sysprog/lectures/multi-thread/multi-thread.html](http://www.cs.kent.edu/~ruttan/sysprog/lectures/multi-thread/multi-thread.html)

## 开始之前

这篇文章主要是为了帮助大家熟悉POSIX线程库以及在实际开发中使用它的特性。我们会具体讲解如何利用这个线程库定义的不同工具
来解决编程中的问题。当然这里隐含了一个假设，就是读者已经了解过并行编程（或者多进程）的相关概念，如果没有这些背景知识
的话，读者可能会感觉到很难理解。不过也没关系，我的另一篇教程里边有专门为只具备线性编程思维的读者提供了对并行编程理论
和相关术语的讲解。

同样的，我假设聪明的你已经熟悉了异步编程模型，那些经常使用桌面环境的人会更容易去接受多线程编程的理念。

当我们谈到POSIX线程的时候，肯定会有人心生疑惑：“我们应该使用哪个标准下的POSIX线程？”。由于POSIX线程标准已经修订了好
多年，人们会发现，依据不同标准的实现有不同的函数集，不同的默认值和不同的细微差别。所以在此说明的是，本教程使用的是v0.5版的Linux内核中的线程库，使用其他操作系统和使用其他版本的读者，需要阅读一下你们对应的系统文档来同本文中的实例进行对应。同时，有些示例代码中使用到了阻塞式的系统调用，它们不能再用户级的线程库中很好的工作（参考另一篇文章：[parallel programming theory tutorial](http://www.actcom.co.il/~choo/lupg/tutorials/parallel-programming-theory/parallel-programming-theory.html#multi_thread_lib) 来获取详细信息）。好了，说了那么多，主要是为了能保证文章中的示例代码能够在其他系统中正常使用，从而提高跨平台性。


## 什么是线程？为什么要使用线程？

线程是一个迷你版的进程，它们拥有自己的栈，能够执行给定的一段代码。但是不同于进程的是，线程通常与其他线程共享记忆体（而
每个进程都拥有一个独立的记忆体区域）。一个线程组就是一个执行相同代码的线程的集合，他们共用记忆体，可以访问相同的全局变
量，拥有同样的文件描述符等等，他们以并行的方式执行（可能是时间片的方式，或者对于多核心系统，他们会真正平行执行）。

使用线程组而不是普通顺序执行程序的好处是多个操作可以同时进行，当一些事件产生的时候，他们能立马被处理（例如：如果我们有
一个线程处理用户接口，另一个线程处理数据库查询，那么我们可以在处理很多用户查询的同时，依然能够响应用户的输入）。

使用线程组而不是进程组的好处是线程间的上下文切换要比进程间的上下文切换要快很多（上下文切换是指系统从一个正在运行的线程或进程切换到去执行另一个线程或进程）。此外，线程间的通信也远远比进程间通信要高效很多。

线程编程有利也有弊，由于线程组共享记忆体，如果一个线程破坏了记忆体，那么其他线程也要受到牵连。但是进程就不同了，操作系
统会将进程之间隔离开，如果一个进程破坏了它的记忆体，那么其他进程不会受到影响。使用进程的另一个好处是，不同的进程可以运
行在不同的机器上，但是线程必须运行在同一台机器上（至少通常情况下是这样的）。

## 创建和销毁线程

当一个多线程程序启动执行到`main()`函数的时候，就会有一个线程运行，这是一个全程线程（full-fledged thread，或者叫主线程），如果想创建一个新的线程，程序中需要使用`pthread_create()`函数

```c
#include <stdio.h>
#include <pthread.h>

void *do_loop(void *data)
{
    int i; // counter, to print numbers
    int j; // counter, for delay
    int me = *((int *)data);
    for (i = 0; i < 10; i++) {
        for (j = 0; j < 50000; j++) // delay loop
            ;
        printf("'%d' - Got '%d'\n", me, i);
    }

    // terminate the thread
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) 
{
    int       thr_id;    // thread ID for the newly created thread
    pthread_t p_thread;  // thread's structure
    int a = 1;           // thread 1 identifying number
    int b = 2;           // thread 2 identifying number

    // create a new thread that will execute 'do_loop()'
    thr_id = pthread_create(&p_thread, NULL, do_loop, (void *)&a);

    // run 'do_loop' in the main thread as well
    do_loop((void *)&b);

    return 0;
}
```

上述这段代码需要特殊说明的是：

1. 因为执行main函数的也是一个线程，所以它在执行`do_loop()`函数的时候跟它创建的线程是并行的；
2. `pthread_create()`函数接收4个参数。第一个是提供该线程的相关信息，第二个是用来定义线程的属性，在上面的示例代码中，我
们使用NULL来表示使用默认的值，第三个参数是传递一个函数来给线程执行，第四个参数是传递给要执行函数的参数。
3. 在函数内部使用一个空的循环只是为了演示线程的并行执行。如果你的CPU足够快，导致你看到一个线程输出前都是同一个线程的输出，那就把空循环的次数改的更大一些。
4. 调用`pthread_exit()`会使当前线程退出，同时释放当前线程占有的私有资源。在线程执行函数的末尾其实是没有必要显示调用这个函数的，因为当函数返回的时候，这个线程自动就会退出。当我们想要退出一个执行中的线程的时候就会非常有用。


使用gcc编译多线程程序的时候，我们需要链接pthread库。确定你的系统中已经安装了线程库，下面是如何编译我们的第一个示例程序：

```shell
gcc pthread_create.c -o pthread_create -lpthread
```

## 用互斥同步线程

使用多线程遇到的基本问题是确保他们不会相互踩到脚，这里指的是在不同的线程中使用同一个数据结构。

例如：假设有两个线程想要修改两个变量。一个线程想将他们都改为0，另一个想改为1.如果两个线程同时执行，我们可能会得到这样
的结果：一个变量是1，而另一个是0.造成这种结果的原因是上下文切换可能会发生在第一个线程将第一个变量设置为0之后，此时第二个线程将两个变量都设置为1，然后第一个线程恢复执行，将第二个变量设置为0，这样就会导致第一个变量为1，第二个变量为0的结果。

### 什么是互斥？

线程库中针对上述问题提供的一个基本的解决方案就是互斥。

### 创建和初始化一个互斥锁

要创建一个互斥锁，我们首先要申明一个`pthread_mutex_t`类型的变量，然后再对其进行初始化。最简单的方法就是将它赋值为`PTHREAD_MUTEX_INITIALIZER`
常量。形如以下代码：

```c
pthread_mutex_t a_mutex = PTHREAD_MUTEX_INITIALIZER;
```

这里需要说明的是：用这种方式创建的互斥锁称为“快速互斥锁”，也就是说，如果一个线程已经获得了一个互斥锁的前提下尝试重新获得
这个锁，那么他就会卡死，形成死锁。

还有另一种被称为“可重入锁”的互斥锁，它能够允许线程多次获取锁而不会发生阻塞。如果这个线程释放了锁，那么它将继续持有锁，直
到它做了通获取锁相同次数的释放锁操作为止。这种锁可以使用常量`PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP`来初始化。

### 获取和释放互斥锁

想要获取互斥锁，我们需要使用`pthread_mutex_lock()`函数，该函数尝试获取一把锁，或者当该锁已经被其他线程持有的时候阻塞当
前线程，这种情况下，当前面的线程释放锁的时候，改函数会返回锁给当前的线程。下面是如何获取锁的操作（假设我们已经事先初始化过了）：

```c
int rc = pthread_mutex_lock(&a_mutex);
if (rc) {
    /* an error has occurred */
    perror("pthread_mutex_lock");
    pthread_exit(NULL);
}

/* mutex is now locked - do your stuff. */
```

当线程完成了相关操作（修改变量或数据结构，处理文件或其他的事情），它需要释放锁，此时需要使用`pthread_mutex_unlock()`函数
，就像下面这样：

```c
rc = pthread_mutex_unlock(&a_mutex);
if (rc) {
    perror("pthread_mutex_unlock");
    pthread_exit(NULL);
}
```

### 销毁一个互斥锁

当我们使用完一把锁之后，我们需要对他进行销毁操作。完成使用是指再没有线程需要使用它了，如果只有一个线程不再使用了，而其它
线程还需要使用，那么就不能销毁。销毁互斥锁需要使用到`pthread_mutex_destroy()`函数：

```c
rc = pthread_mutex_destroy(&a_mutex);
```

销毁完之后，变量`a_mutex`就不能再被用于锁操作了，除非它再次被初始化。也就是说，如果销毁太早，后续还有线程尝试获取或释放
锁，那么该线程会从调用lock或者unlock的函数得到一个`EINVAL`的错误。

### 使用互斥锁——一个完整的例子

我们已经知道了一个互斥锁的完整的生命周期，那么让我们来看一个使用互斥锁的完整程序。程序会产生两个员工来竞争"employee of the day"的荣耀。我们将会创建3个线程，一个用来让Danny获得"employee of the day"的荣誉，另一个让Moshe获得，第三个负责确保只有一个人获得。这里提供两份代码，一个使用了互斥锁，另一个没有使用。运行这些程序，观察他们的区别，你会发现互斥锁对于多线程环境
编程是非常重要的。

```c
#include <stdio.h>
#include <pthread.h>

#define num_employees 2

/* global mutex for out program. assignment initializes it */
pthread_mutex_t a_mutex = pthread_mutex_initializer;

struct employee {
    int number;
    int id;
    char first_name[20];
    char last_name[20];
    char department[30];
    int room_number;
};

/* global variable - our employee array, with 2 employees */
struct employee employees[] = {
    { 1, 12345678, "danny", "cohen", "accounting", 101 },
    { 2, 87654321, "moshe", "levy", "programmers", 202 },
};

/* global variable - employee of the day. */
struct employee employee_of_the_day;

void copy_employee(struct employee *from, struct employee *to)
{
    int rc; /* contain mutex lock/unlock results */

    /* lock the mutex, to assure exclusive access to 'a' and 'b'. */
    rc = pthread_mutex_lock(&a_mutex);

    to->number = from->number;
    to->id = from->id;
    strcpy(to->first_name, from->first_name);
    strcpy(to->last_name, from->last_name);
    strcpy(to->department, from->department);
    to->room_number = from->room_number;

    /* unlock mutex */
    rc = pthread_mutex_unlock(&a_mutex);
}


void *do_loop(void *data)
{
    int my_num = *((int *)data);
    while (1) {
        /* set employee of the day to be the one with number 'my_num'. */
        copy_employee(&employees[my_num - 1], &employee_of_the_day);
    }
}

int main(int argc, char *argv[]) 
{
    int       i;                /* loop counter */
    int       thr_id1;          /* thread id for the first new thread */
    int       thr_id2;          /* thread id for the second new thread */
    pthread_t p_thread1;        /* first thread's structure */
    pthread_t p_thread2;        /* second thread's structure */
    int       num1 = 1;         /* thread 1 employee number */
    int       num2 = 2;         /* thread 2 employee number */
    struct    employee eotd;    /* local copy of 'employee of the day' */
    struct    employee *worker; /* pointer to currently checked employee */

    /* initialize employee of the day to first 1. */
    copy_employee(&employees[0], &employee_of_the_day);

    /* create a new thread that will execute 'do_loop' with 1 */
    thr_id1 = pthread_create(&p_thread1, null, do_loop, (void *)&num1);
    
    /* create a new thread that will execute 'do_loop' with 2 */
    thr_id2 = pthread_create(&p_thread2, null, do_loop, (void *)&num2);

    /* run a loop that verfies integrity of 'employee of the day' many */
    for (i = 0; i < 6000; i++) {
        copy_employee(&employee_of_the_day, &eotd);
        worker = &employees[eotd.number - 1];

        if (eotd.id != worker->id) {
            printf("mismatching 'id', %d != %d (loop '%d')\n", eotd.id, worker->id, i);
            exit(0);
        }

        if (strcmp(eotd.first_name, worker->first_name) != 0) {
            printf("mismatching 'first_name', %s != %s (loop '%d')\n", eotd.first_name, worker->first_name, i);
            exit(0);
        }

        if (strcmp(eotd.last_name, worker->last_name) != 0) {
            printf("mismatching 'last_name', %s != %s (loop '%d')\n", eotd.last_name, worker->last_name, i);
            exit(0);
        }

        if (strcmp(eotd.department, worker->department) !=0) {
            printf("mismatching 'department', %s != %s (loop '%d')\n", eotd.department, worker->department, i);
            exit(0);
        }

        if (eotd.room_number != worker->room_number) {
            printf("mismatching 'room_number', %d != %d (loop '%d')\n", eotd.room_number, worker->room_number, i);
            exit(0);
        }
    }

    printf("glory, employees contents was always consistent\n");
    return 0;
}
```


### 饥饿和死锁

## 精简同步——条件变量


