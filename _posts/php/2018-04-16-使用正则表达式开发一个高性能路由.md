---
layout: post
title: 使用正则表达式开发一个高性能路由
author: 刘邦
excerpt: ""
catalog: true
tags: php
category: php
comments: true
---

原文地址：[http://nikic.github.io/2014/02/18/Fast-request-routing-using-regular-expressions.html](http://nikic.github.io/2014/02/18/Fast-request-routing-using-regular-expressions.html)

前一些日子，我发现了一个叫做[Pux](https://github.com/c9s/Pux)的路由库，这个路由库声称自己比现有的路由要快很多，为了实现这个特点，该库使用了C语言编写了PHP扩展。

然而，当我瞅了几眼它的代码后，我非常怀疑这个库在路由过程中做了错误的优化，而且我能够很容易在不适用扩展的情况下做出更高性能的实现。
当我在看了benchmarking代码后更加确定了我的怀疑，因为我发现这里仅仅只是对及其确定的单个路由做了测试。

为了进一步研究这个问题，我写了一个轻量的路由库：[FastRoute](https://github.com/nikic/FastRoute)。这个库中实现的分发过程接下来我会具体描述。为了给出一些前期印象，这里先给出一个
同Pux库的benchmark结果：

```
1 placeholder  | Pux (no ext) | Pux (ext) | FastRoute
-----------------------------------------------------
First route    | 0.17 s       | 0.13 s    | 0.14 s
Last route     | 2.51 s       | 1.20 s    | 0.49 s
Unknown route  | 2.34 s       | 1.10 s    | 0.34 s

9 placeholders | Pux (no ext) | Pux (ext) | FastRoute
-----------------------------------------------------
First route    | 0.22 s       | 0.19 s    | 0.20 s
Last route     | 2.65 s       | 1.78 s    | 0.59 s
Unknown route  | 2.50 s       | 1.49 s    | 0.40 s
```

这个benchmark使用了100个路由，分别对最好和最坏的情况做了测试。而且分两个方面进行：一个是只包含一个占位符的路由，另一个是包含9个占位符的路由。整个过程
重复了上千次。

在进入到正式的主题之前，让我再强调最后一点：这篇文章表面上是关于路由的，但是我真正想聊得是一般的基于正则 表达式的调度过程。从某种程度上说，这是对我之前写的"[lexing performance in PHP](https://nikic.github.io/2011/10/23/Improving-lexing-performance-in-PHP.html)"的重复。

## 关于路由的问题

为了确保我们没有跑题，让我们首先来定义一下“路由”。在大多数实现形式中，它是类似于如下形式的一系列过程：

```php
$r-addRoute('GET', '/usr/{name}/{id:\d+}', 'handler0');
$r->addRoute('GET', '/user/{id:\d+}', 'handler1');
$r->addRoute('GET', '/user/{name}', 'handler2');
```

接着像下面这样分发URI:

```php
$d->dispatch('GET', '/user/nikic/42');
// => provides 'handler0' and ['name' => 'nikic', 'id' => '42']
```


