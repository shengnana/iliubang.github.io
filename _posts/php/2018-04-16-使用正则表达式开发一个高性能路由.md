---
layout: post
title: 使用正则表达式开发一个高性能路由
author: 刘邦
excerpt: ""
catalog: true
tags: php
category: php
comments: true
---

原文地址：[http://nikic.github.io/2014/02/18/Fast-request-routing-using-regular-expressions.html](http://nikic.github.io/2014/02/18/Fast-request-routing-using-regular-expressions.html)

前一些日子，我发现了一个叫做[Pux](https://github.com/c9s/Pux)的路由库，这个路由库声称自己比现有的路由要快很多，为了实现这个特点，该库使用了C语言编写了PHP扩展。

然而，当我瞅了几眼它的代码后，我非常怀疑这个库在路由过程中做了错误的优化，而且我能够很容易在不适用扩展的情况下做出更高性能的实现。
当我在看了benchmarking代码后更加确定了我的怀疑，因为我发现这里仅仅只是对及其确定的单个路由做了测试。

为了进一步研究这个问题，我写了一个轻量的路由库：[FastRoute](https://github.com/nikic/FastRoute)。这个库中实现的分发过程接下来我会具体描述。为了给出一些前期印象，这里先给出一个
同Pux库的benchmark结果：

```
1 placeholder  | Pux (no ext) | Pux (ext) | FastRoute
-----------------------------------------------------
First route    | 0.17 s       | 0.13 s    | 0.14 s
Last route     | 2.51 s       | 1.20 s    | 0.49 s
Unknown route  | 2.34 s       | 1.10 s    | 0.34 s

9 placeholders | Pux (no ext) | Pux (ext) | FastRoute
-----------------------------------------------------
First route    | 0.22 s       | 0.19 s    | 0.20 s
Last route     | 2.65 s       | 1.78 s    | 0.59 s
Unknown route  | 2.50 s       | 1.49 s    | 0.40 s
```

这个benchmark使用了100个路由，分别对最好和最坏的情况做了测试。而且分两个方面进行：一个是只包含一个占位符的路由，另一个是包含9个占位符的路由。整个过程
重复了上千次。

在进入到正式的主题之前，让我再强调最后一点：这篇文章表面上是关于路由的，但是我真正想聊得是一般的基于正则 表达式的调度过程。从某种程度上说，这是对我之前写的"[lexing performance in PHP](https://nikic.github.io/2011/10/23/Improving-lexing-performance-in-PHP.html)"的重复。

## 关于路由的问题

为了确保我们没有跑题，让我们首先来定义一下“路由”。在大多数实现形式中，它是类似于如下形式的一系列过程：

```php
$r-addRoute('GET', '/usr/{name}/{id:\d+}', 'handler0');
$r->addRoute('GET', '/user/{id:\d+}', 'handler1');
$r->addRoute('GET', '/user/{name}', 'handler2');
```

接着像下面这样分发URI:

```php
$d->dispatch('GET', '/user/nikic/42');
// => provides 'handler0' and ['name' => 'nikic', 'id' => '42']
```

为了达到更高的抽象度，我们会使用HTTP Method和一些特定的格式来定义路由，在这篇文章中，我唯一要阐述的是在分发层面上，路由是如何被解析的，而关于分发的数据是如何
生成的将不会做深入说明。

那么，在路由过程中，慢的地方在哪呢？在一个大型设计的系统中很可能会生成几十个对象，调用几百个方法。Pux在减少这种开销上做了很伟大的工作。但是，在更基础的层面上，
路由分发过程中导致开销大的因素是一系列几十个或几百个甚至几千个路由正则来跟现有的URI做匹配。如何让他变得更快是本文将要讨论的话题。

## 组合正则

优化的基本思想是避免一个个进行正则匹配，而是将这些正则合并成一个大正则，这样就只需要匹配一次，我们用前面的例子来说，组合正则如下：

```php
Individual regexes:

    ~^/user/([^/]+)/(\d+)$~
    ~^/user/(\d+)$~
    ~^/user/([^/]+)$~

Combined regex:

    ~^(?:
        /user/([^/]+)/(\d+)
      | /user/(\d+)
      | /user/([^/]+)
    )$~x<Paste>
```

转换起来非常简单，只需要将所有的单个正则用OR连接起来。当与该正则匹配的时候，如何确定是哪个路由匹配上了呢？为此，让我们来看看简单的`preg_match`执行的结果：

```php
preg_match($regex, '/user/nikic', $matches);
=> [
    "/user/nikic",   # full match
    "", "",          # groups from first route (empty)
    "",              # groups from second route (empty)
    "nikic",         # groups from third route (used!)
]
```

所以，技巧就是在`$matches`数组中找到第一个不为空的元素。为了能够使用匹配的结果，你还需要一个额外的数据结构来映射`$matches`索引到匹配的路由

```php
[
    1 => ['handler0', ['name', 'id']],
    3 => ['handler1', ['id']],
    4 => ['handler2', ['name']],
]
```

下面是一个简单的实现：

```php
public function dispatch($uri) {
    if (!preg_match($this->regex, $uri, $matches)) {
        return [self::NOT_FOUND];
    }

    // find first non-empty match (skipping full match)
    for ($i = 1; '' === $matches[$i]; ++$i);

    list($handler, $varNames) = $this->routeData[$i];

    $vars = [];
    foreach ($varNames as $varName) {
        $vars[$varName] = $matches[$i++];
    }
    return [self::FOUND, $handler, $vars];
}
```


