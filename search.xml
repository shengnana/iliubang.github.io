<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[语法]]></title>
      <url>http://iliubang.github.io/2017/02/17/%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>文法自然地描述了大多数程序设计语言构造的层次化语法结构。例如，Java中的<code>if-else</code>语句通常具有如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (expression) statement else statement</div></pre></td></tr></table></figure></p>
<p>即一个<code>if-else</code>语句由关键字<code>if</code>、左括号、表达式、右括号、一个语句、关键字<code>else</code>和另一个语句连接而成。如果我们用变量<code>expr</code>来表示表达式，用变量<code>stmt</code>来表示语句，那么这个构造规则可以表示为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stmt -&gt; if (expr) stmt else stmt</div></pre></td></tr></table></figure></p>
<p>其中箭头(-&gt;)可以读作“可以具有如下形式”。这样的规则称为产生式(production)。在一个产生式中，像关键字<code>if</code>和括号这样的词法元素称为终结符号(terminal)。像<code>expr</code>和<code>stmt</code>这样的变量表示终结符号的序列，他们称为非终结符号(nonterminal)。<br><a id="more"></a></p>
<h1 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h1><p>一个上下文无关文法(context-free grammar)由四个元素组成：<br>1）一个终结符号集合，他们有时也称为“词法单元”。终结符号是该文法所定义的语言的基本符号的集合。<br>2）一个非终结符号集合，他们有时也称为“语法变量”。每个非终结符号表示一个终结符号串的集合。<br>3）一个产生式集合，其中每个产生式包括一个称为产生式头或左部的非终结符号，一个箭头，和一个称为产生式体或右部的由终结符号及非终结符号组成的序列。产生式主要用来表示某个构造的某种书写形式。如果产生式头非终结符号代表一个构造，那么该产生式体就代表了该构造的一种书写方式。<br>4）指定一个非终结符号为开始符号。</p>
<h2 id="词法单元和终结符号"><a href="#词法单元和终结符号" class="headerlink" title="词法单元和终结符号"></a>词法单元和终结符号</h2><p>在编译器中，词法分析器读入源程序中的字符序列，将他们组织为具有词法含义的词素，生成并输出代表这些词素的词法单元序列。词法单元由两部分组成：名字和属性值。词法单元的名字是语法分析器进行语法分析时使用的抽象符号。我们常常把这些词法单元名字称为终结符号，因为他们在描述程序设计语言的文法中是以终结符号的形式出现的。如果词法单元具有属性值，那么这个值就是一个指向符号表的指针，符号表中包含了该词法单元的附加信息。这些附加信息不是文法的组成部分，因此在我们讨论语法分析时，通常将词法单元和终结符号当做同义词。</p>
<p>在描述文法的时候，我们会列出该文法的产生式，并且首先列出开始符号对应的产生式。我们假设数位、符号（如&lt;、&lt;=）和黑体字符串（如<strong>while</strong>）都是终结符号。斜体字符串表示非终结符号，所有非斜体的名字或符号都可以看做是终结符号。为了表示方便，以同一个非终结符号为头部的多个产生式的体可以放在一起表示，不同体之间用符号 |（读作“或”）分割。</p>
<p>如果某个非终结符号是某个产生式的头部，我们就说该产生式是该非终结符号的产生式。一个终结符号串是由零个或多个终结符号组成的序列。零个终结符号组成的串称为空串(enpty string)，记为：$\epsilon$.</p>
<h1 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h1><p>根据文法推导符号串时，我们首先从开始符号出发，不断将某个非终结符号替换成该非终结符号的某个产生式的体。可以从开始符号推导得到的所有终结符号串的集合称为该文法定义的语言(language)。</p>
<p>语法分析(parsing)的任务是：接受一个终结符号串作为输入，我们从文法的开始符号推导出这个串的方法。如果不能从文法的开始符号推导得到该终结符号串，则报告该终结符号串中包含语法错误。语法分析是所有编译过程中最基本的问题之一。</p>
<h1 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h1><p>语法分析树用图形的方式展现了从文法开始符号推导出相应语言中的符号串的过程。如果非终结符号A有一个产生式$A \to XYZ$，那么在语法分析树中就可能有一个标号为A的内部结点，该结点有三个子结点，从左向右的标号分别为X、Y、Z:</p>
<p>正式的讲，给定一个上下文无关文法，该文法的一颗语法分析树(parse tree)是具有以下性质的树：<br>1）根结点的标号为文法的开始符号。<br>2）每个叶子结点的标号为一个终结符号或$\epsilon$。<br>3）每个内部结点的标号为一个非终结符号。<br>4）如果费终结符号A是某个内部结点的标号，并且它的子结点的标号从左到右分别为$X_1, X_2, …, X_n$, 那么必然存在产生式$A \to X_1X_2…X_n$，其中$X_1, X_2, …, X_n$既可以是终结符号，也可以是非终结符号。作为一个特殊情况，如果$A \to \epsilon$是一个产生式，那么一个标号为$A$的结点可以只有一个标号为$\epsilon$的子结点。</p>
<h2 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h2><p>树型数据结构在编译系统中起着重要的作用。</p>
<ul>
<li>一棵树由一个或多个结点(node)组成。结点可以带有标号(label)。</li>
<li>树有且只有一个根(root)结点。每个非根结点都有唯一的父(parent)结点；根结点没有父结点。当我们画树的时候，将一个结点的父结点画在它的上方，并在父、子结点之间画一条边。因此根结点是最高(顶层的)结点。</li>
<li>如果结点$N$是结点$M$的父结点，那么$M$就是$N$的子(child)结点。一个结点的各个子结点彼此称为兄弟(sibling)结点。他们之间是有序的，按照从左向右的方式排列。</li>
<li>没有子结点的结点称为叶子(leaf)结点。其他结点，即有一个或多个子结点的结点，称为内部结点(interior node)。</li>
<li>结点$N$的后代(descendant)结点要么是结点$N$本身，要么是$N$的子结点，要么是$N$的子结点的子结点，以此类推。如果结点$M$是结点$N$的后代结点，那么结点$N$是结点$M$的祖先(ancestor)结点。</li>
</ul>
<p>一个文法的语言的另一个定义是指任何能够由某课语法分析书生成的符号串的集合。为一个给定的终结符号串构建一颗语法分析树的过程称为对该符号串进行语法分析。</p>
<h1 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h1><p>在根据一个文法讨论某个符号串的结构时，我们必须非常小心。一个文法可能有多颗语法分析树能够生成同一个给定的终结符号串。这样的文法称为具有二义性(ambiguous)。要证明一个文法具有二义性，我们只需要找到一个终结符号串，说明它是两颗以上语法分析树的结果。因为具有两颗以上语法分析树的符号串通常具有多个含义，所以我们需要为编译应用设计出没有二义性的文法，或者在使用二义性文法时使用附加的规则来消除二义性。</p>
<h1 id="运算符的结核性"><a href="#运算符的结核性" class="headerlink" title="运算符的结核性"></a>运算符的结核性</h1><p>依照惯例，$9+5+2$等价于$(9+5)+2$，$9-5-2$等价于$(9-5)-2$。当一个运算分量的左右两侧都有运算符时，我们需要一些规则来决定哪个运算符被应用于该运算分量。我们说运算符”+”是左结合(associate)的，因为当一个运算分量左右两侧都有”+”号时，它属于其左边的运算符。在大多数程序设计语言中，加、减、乘、除四种算术运算符都是左结合的。<br>某些常用的运算符是右结合的，比如指数运算。作为另一个例子，C语言中的赋值运算符”=”以及其后裔(即”+=”、”-=”等)也是右结合的。也就是说，对表达式$a=b=c$的处理和对表达式$a=(b=c)$的处理相同。<br>带有右结合运算符的串，比如$a=b=c$，可以由如下文法产生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">right -&gt; letter = right | letter</div><div class="line">letter -&gt; a | b | ... | z</div></pre></td></tr></table></figure></p>
<h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p>考虑表达式$9+5\ast2$。该表达式有两种可能得皆是，即$(9+5)\ast2$或$9+(5\ast2)$。<code>+</code>和$\ast$的结合性规则只能作用于同一运算符的多次出现，因此他们无法解决这个二义性。为此，当多种运算符出现时，我们需要给出一些规则来定义运算符之间的相对优先关系。<br>如果$\ast$先于<code>+</code>获得运算分量，我们就说$\ast$比<code>+</code>具有更高的优先级。在通常的算术中，乘法和除法比加法和减法具有更高的优先级。因此在表达式$9+5\ast2$和$9\ast5+2$中，都是运算分量5首先参与$\ast$运算，即这两个表达式分别等价于$9+(5\ast2)$和$(9\ast5)+2$。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[代理模式]]></title>
      <url>http://iliubang.github.io/2017/02/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="代理模式概述"><a href="#代理模式概述" class="headerlink" title="代理模式概述"></a>代理模式概述</h1><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<h1 id="代理模式的优点"><a href="#代理模式的优点" class="headerlink" title="代理模式的优点"></a>代理模式的优点</h1><p><strong>1. 职责清晰</strong><br>真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。</p>
<p><strong>2. 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用</strong></p>
<p><strong>3. 高扩展性</strong></p>
<a id="more"></a>
<h1 id="代理模式-Proxy-概述"><a href="#代理模式-Proxy-概述" class="headerlink" title="代理模式(Proxy)概述"></a>代理模式(Proxy)概述</h1><p>代理模式是23种常用的OOP软件开发的设计模式之一。代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不合适或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。</p>
<p>以下内容转载于<a href="https://my.oschina.net/wizardmerlin/blog/513078" target="_blank" rel="external">https://my.oschina.net/wizardmerlin/blog/513078</a></p>
<hr>
<p>2007年，感觉很无聊，于是就玩了一段时间的网络游戏，游戏名就不说了，要不就有做广告的嫌疑，反正就是打怪、升级、砍人、被人砍，然后继续打怪、升级、打怪、升级。。。我花了两个月的时间升级到了80级，已经很有成就感了，但是还被人杀死，高手到处都是，GM(Game Master,游戏管理员)也不管，对于咱这种非RMB玩家基本上都是懒得搭理。在这段时间我是体会到了网络游戏的苦与乐，参与家族（工会）攻城，胜利后那叫一个乐呀，感觉自己真是一个“狂暴战士”，无往不胜！那苦是什么呢？就是升级，为了升一级，就要到处杀怪，做任务，那个游戏还很变态，外挂管的很严，基本上出个外挂，没了两天就开始封号，不敢用，升级基本上都要靠自己手打，累呀！我曾经的记录是连着打了23个小时，睡觉在梦中还和大BOSS在PK。有这样一段经历还是很有意思的，作为架构师是不是可以把这段经历通过架构的方式记录下来呢？当然可以了，我们把这段打游戏的过程系统化，非常简单的一个过程，如图所示：</p>
<p><img src="/img/01161112_84ux.gif" alt="游戏过程"></p>
<p>太简单了，定义一个接口<code>IGamePlayer</code>，是所有喜欢网络游戏的玩家，然后定义一个具体的实现类<code>IGamePlayer</code>，实现每个游戏爱好者为了玩游戏要执行的功能。代码也非常简单，我们先来看<code>IGamePlayer</code>，代码清单如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//游戏者接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="comment">//登录游戏</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//杀怪，网络游戏的主要特色</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//升级</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简单，定义了三个方法，分别是我们在网络游戏中最常用的功能：登录游戏，杀怪和升级，其实实现类如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//游戏者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name = <span class="string">""</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//通过构造函数传递名称</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(String _name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = _name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//打怪，最期望的就是杀老怪</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"在打怪"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//进游戏之前你肯定要登录吧，这是一个必要条件</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"登录名为"</span> + user + <span class="string">"用户名"</span> + <span class="keyword">this</span>.name + <span class="string">"登录成功！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//升级，升级有很多方法，花钱买一种，做任务也是一种</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"　又升了一级！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实现类中通过构造函数传递进来玩家的姓名，方便进行后期的调试工作。</p>
<p><em>客户端调用简单再次略过</em></p>
<p>心理学家告诉我们，人类对于苦难的记忆比对喜悦的记忆要深刻，但是人类对于喜悦是“趋利”性的，每个人都想Happy，都不想让苦难靠近，要想获得幸福，苦难也是再所难免的，我们的网游生涯也是如此，游戏打的时间长了，腰酸背痛，眼睛干涩，手臂酸麻，等等，也就是网络成瘾综合征都出来了，其结果就是类似吃了那个“一日丧命散”，“筋脉逆流，胡思乱想，而导致走火入魔”。那怎么办呢？我们想玩游戏，但又不想触碰到游戏中的烦恼？如何解决呢？<br>有办法，现在游戏代练的公司非常多，我把自己的账号交给代练员，由他们去帮我们升级，去打怪，非常好的想法，我们来修改一下类图，如下所示：</p>
<p><img src="/img/01161112_WnAK.gif" alt=""></p>
<p>在类图中增加了一个<code>GamePlayerProxy</code>类来代表游戏代练者，它也不能有作弊的方法呀，游戏代练者也是手动打怪呀，因此同样继承<code>IGamePlayer</code>接口，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//通过构造函数传递要对谁进行代练</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(IGamePlayer _gamePlayer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer = _gamePlayer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//代练杀怪</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.killBoss();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//代练登录</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.login(user, password);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//代练升级</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.upgrade();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，首先通过构造函数说明要代谁打怪升级，然后通过手动开始代用户打怪、升级。场景类Client代码也稍作改动，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>);</div><div class="line"></div><div class="line">        IGamePlayer proxy = <span class="keyword">new</span> GamePlayerProxy(player);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"开始时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line"></div><div class="line">        proxy.login(<span class="string">"zhangsan"</span>, <span class="string">"password"</span>)</div><div class="line"></div><div class="line">        proxy.killBoss();</div><div class="line"></div><div class="line">        proxy.upgrade();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"结束时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果也完全相同，还是张三这个用户在打怪</p>
<p>是的，没有任何改变，但是你有没有发觉，你的游戏已经在升级，有人在帮你干活了！终于升级到120级，然后基本上是本服无敌手，除了GM外，这个你可惹不起！这就是代理模式。</p>
<h1 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h1><p>代理模式(Proxy Pattern)是一个使用率非常高的模式，其定义如下：<br>provide a surrogate or placeholder for another object to control access to it. 为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>下图是代理模式的通用类图</p>
<p><img src="/img/clip_image006_2.gif" alt="代理模式通用类图"></p>
<p>代理模式也叫委托模式，他是一项基本的设计技巧，许多其他的模式，如状态模式，策略模式，访问者模式本质上是在更特殊的场合采用了委托模式，而且在日常的应用中，代理模式可以提供非常好的访问控制，在一些著名开源软件中也经常见到它的影子，如Strus2的Form元素的映射就采用了代理模式（准确说是动态代理模式）。我们先看一下类途中定义的三个角色：</p>
<p><code>Subject</code>抽象主题角色：抽象主题角色可以是抽象类也可以是接口，是一个最普遍的业务类型定义，无特殊要求。</p>
<p><code>RealSubject</code>具体主题角色：也叫作被委托角色，被代理角色，它才是冤大头，是业务逻辑的具体执行者。</p>
<p><code>Proxy</code>代理主题角色：也叫作委托类，代理类，它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完前后做预处理和善后处理的工作。</p>
<p>我们首先来看<code>Subject</code>抽象主题类的通用源码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">//定义一个方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在接口中我们定义了一个方法<code>request</code>来作为方法的代表，<code>RealSubject</code>对它进行实现，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">//实现方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>RealSubject</code>是一个正常的业务实现类，代理模式的核心就是在代理类上，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">//要代理哪个实现类</span></div><div class="line">    <span class="keyword">private</span> Subject subject = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//默认被代理者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subject = <span class="keyword">new</span> Proxy();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//通过构造函数传递代理者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Object...objects)</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.before();</div><div class="line">        <span class="keyword">this</span>.subject.request();</div><div class="line">        <span class="keyword">this</span>.after();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//预处理</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//善后处理</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，大家别惊讶，为什么会出现<code>before</code>和<code>after</code>方法，继续看下去，这是一个“引子”，能够引出一个崭新的编程模式。<br>一个代理类可以代理多个被委托者或代理者，因此一个代理类具体代理那个真实主题角色，是由场景决定的，当然，最简单的情况就是一个主题类一个代理类，这是最简洁的代理模式。在通常情况下，一个接口只需要一个代理类就可以了，具体代理哪个实现类由高层模块来决定，也就是在代理类的构造函数中传递被代理者，例如我们可以在代理类<code>Proxy</code>中增加代码如下的构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject _subject)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.subject = _subject;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你要代理谁，产生该代理的实例，然后把被代理者传递进来，该模式在实际的项目应用中比较广泛。</p>
<h1 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h1><p>我相信第一次接触到代理模式的读者肯定很郁闷，为什么要用代理呀，是的，为什么要用代理？想想现实世界吧，你为什么要找代理律师，你去打官司，为什么要找到个律师？因为你不想参与中间过程的是是非非，只要完成自己的答辩就行，其他的比如事前调查，事后追查都由律师来搞定，这就是为了减轻你的负担。代理模式使用非常多，大家可以看看Spring AOP，这是一个非常典型的动态代理。</p>
<h1 id="代理模式的扩展"><a href="#代理模式的扩展" class="headerlink" title="代理模式的扩展"></a>代理模式的扩展</h1><h2 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h2><p>在网络上代理服务器设置分为透明代理和普通代理，什么意思呢？透明代理就是用户不能设置代理服务器地址，就可以直接访问，也就是说代理服务器对用户来说透明的，看不到，不用知道它的存在；普通代理是需要用户自己设置代理服务器地址，用户必须知道代理的存在。我们设计模式中的普通代理和强制代理也是类似的一种结构，普通给代理就是我们要知道代理的存在，也就是类似于<code>GamePlayerProxy</code>这个类的存在，然后才能访问；强制代理则是调用者直接调用真实角色，而不用关心代理是否存在，其代理的产生是由真实角色决定管的，这样解释还是比较复杂，我们还是用实例来讲解。<br>首先说普通代理，他的要求就是客户端只能访问代理角色，而不能访问真实角色，这是比较简单的，我们以上面的例子作为扩展，我自己作为一个游戏玩家，我肯定自己不练级了，也即是场景类不能再直接<code>new</code>一个<code>GamePlayer</code>对象了，它必须由<code>GamePlayerProxy</code>来进行模拟场景，类图如下：<br><img src="/img/01161112_rdxV.gif" alt=""><br>改动很小，仅仅修改了两个实现类的构造函数，<code>GamePlayer</code>的构造函数增加了<code>_gamePlayer</code>参数，而代理角色则只要传入代理者的名字即可，而不需要说是替哪个对象做代理，<code>GamePlayer</code>代码清单如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name = <span class="string">''</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(IGamePlayer _gamePlayer, String _name)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (_gamePlayer == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不能创建真实角色!"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.name = _name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"在打怪"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"登录名为"</span> + user + <span class="string">" 的用户 "</span> + <span class="keyword">this</span>.name + <span class="string">"登录成功"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"又升了一级"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在构造函数中，传递进来一个<code>IGamePlayer</code>对象，检查谁能创建真实角色，当然还可以有其他的限制，比如类名必须为<code>Proxy</code>类等等，读者可以根据实际情况进行扩展。<code>GamePlayerProxy</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            gamePlayer = <span class="keyword">new</span> GamePlayer(<span class="keyword">this</span>, name);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.gamePlayer.killBoss(); </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.login(user, password);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.upgrade();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仅仅修改了构造函数，传递进来一个代理者名称，即可进行代理，在这种改造下，系统更加简洁了，调用者只知道代理存在就可以，不用知道代理了谁。<br>在该模式下，调用者只知道代理而不用知道真实角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色爱怎么修改就怎么修改，对高层次的模块没有任何影响，只要你实现了接口所对应的方法，该模式非常适合对扩展性要求高的场合。当然，在实际的项目中，一般都是通过约定来禁止<code>new</code>一个真实的角色，也是一个非常好的方案。<br>注意，普通代理模式的约束问题，尽量通过团队内的编码规范类约束，因为每一个主题类是可以被重用的和可维护的，使用技术约束的方式对系统维护是一种非常不利的因素。</p>
<h2 id="强制代理"><a href="#强制代理" class="headerlink" title="强制代理"></a>强制代理</h2><p>强制代理在设计模式中比较另类，为什么这么说呢？一般的思维都是通过代理找到真实的角色，但是强制代理却要“强制”，你必须通过真实角色查找到代理角色，否则你不能访问，甭管你是通过代理类还是通过直接<code>new</code>一个主题角色类，都不能访问，只有通过真实角色指定的代理类才能访问，也就是说由真实角色管理代理角色，这么说吧，高层模块<code>new</code>了一个真实角色的对象，返回的确实代理角色，者就好比你和一个明星比较熟，相互认识，有件事情需要向他确认一下，于是就直接拨通了明星的电话：<br>“喂，沙比呀，偶要见一下xxx导演，你帮下忙吧！”<br>“不行啊衰哥，我这几天很忙呀，你找我经纪人吧…”<br>郁闷了吧，你是想直接绕过他的代理，谁知道返回的还是他的代理，这就是强制代理，你可以不用知道代理的存在，但是你所作所为还是需要代理为你提供。我们把上面的例子稍作修改就可以完成。</p>
<p><img src="/img/clip_image010_2.gif" alt=""></p>
<p>在接口上增加了一个<code>getProxy</code>方法，真实角色<code>GamePlayer</code>可以指定一个自己的代理，除了代理外谁都不能访问。我们来看代码，先看<code>IGamePlayer</code>接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仅仅增加了一个<code>getProxy</code>方法，指定要访问自己必须通过哪个代理，实现类也要做适当的修改，先看真实角色<code>GamePlayer</code>，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String name = <span class="string">''</span>;</div><div class="line"></div><div class="line">    <span class="comment">//我要的代理是谁</span></div><div class="line">    <span class="keyword">private</span> IGamePlayer proxy = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(String _name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = _name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.proxy = <span class="keyword">new</span> GamePlayerProxy(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.proxy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isProxy()) &#123;</div><div class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">"在打怪"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"请使用指定的代理访问"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isProxy()) &#123;</div><div class="line">            System.out.println(<span class="string">"登录名为"</span>+user+<span class="string">" 的用户 "</span> + <span class="keyword">this</span>.name + <span class="string">"登录成功"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"请使用指定的代理访问"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isProxy()) &#123;</div><div class="line">            System.out.println(<span class="string">"升级"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"请使用指定的代理访问"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.proxy == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>增加了一个私有方法，检查是否是自己指定的代理，是指定的代理则允许访问，否则不允许访问。我们再来看看代理角色，代码清单如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(IGamePlayer _gamePlayer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer = _gamePlayer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.killBoss();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.login(user, password);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.upgrade();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代理角色也可以再次被代理，这里我们就没有继续延伸下去了，查找代理的方法就返回自己的实例。代码都写完毕了，我们先按照常规的思路来运行一下，直接<code>new</code>一个真实的角色，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    	<span class="comment">//定义一个游戏角色</span></div><div class="line">    	IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>)；</div><div class="line">    	<span class="comment">//开始打游戏，记下时间戳</span></div><div class="line">    	System.out.println(<span class="string">"开始时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">    	player.login(<span class="string">"zhangsan"</span>, <span class="string">"password"</span>);</div><div class="line">    	player.killBoss();</div><div class="line">    	player.upgrade();</div><div class="line">    	System.out.println(<span class="string">"结束时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想看看能运行吗？</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>请使用指定的代理访问</p>
<p>请使用指定的代理访问</p>
<p>请使用指定的代理访问</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>它要求你必须通过代理来访问，你想要直接访问它，门儿都没有，好，你要我通过代理来访问，那就生产一个代理，如代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>);</div><div class="line"></div><div class="line">		IGamePlayer proxy = <span class="keyword">new</span> GamePlayerProxy(player);</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"开始时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">		</div><div class="line">		proxy.login(<span class="string">"zhangsan"</span>, <span class="string">"password"</span>);</div><div class="line"></div><div class="line">		proxy.killBoss();</div><div class="line"></div><div class="line">		proxy.upgrade();</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"结束时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这次能访问吗？还是不行，结果如下所示：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>请使用指定的代理访问</p>
<p>请使用指定的代理访问</p>
<p>请使用指定的代理访问</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>同样是不能访问，为什么呢？它不是真实角色指定的对象，这个代理对象是你自己new出来的，当然真实对象不认了，这就好比是那个明星，人家已经告诉你去找她的代理人了，你随便找个代理人能成吗？你必须去找她指定的代理才成！我们修改一下场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="comment">//定义个游戏的角色</span></div><div class="line">     IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>);</div><div class="line"> </div><div class="line">     <span class="comment">//获得指定的代理</span></div><div class="line">     IGamePlayer proxy = player.getProxy();</div><div class="line"> </div><div class="line">     <span class="comment">//开始打游戏，记下时间戳</span></div><div class="line">     System.out.println(<span class="string">"开始时间是：2009-8-25 10:45"</span>);</div><div class="line"> </div><div class="line">     proxy.login(<span class="string">"zhangSan"</span>, <span class="string">"password"</span>);</div><div class="line"> </div><div class="line">     <span class="comment">//开始杀怪</span></div><div class="line">     proxy.killBoss();</div><div class="line"> </div><div class="line">     <span class="comment">//升级</span></div><div class="line">     proxy.upgrade();</div><div class="line"> </div><div class="line">     <span class="comment">//记录结束游戏时间</span></div><div class="line">     System.out.println(<span class="string">"结束时间是：2009-8-26 03:40"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>登录名为zhangSan 的用户 张三登录成功！</p>
<p>张三在打怪！</p>
<p>张三 又升了一级！</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>OK，可以正常访问代理了。强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色，高层模块只要调用getProxy就可以访问真实角色的所有方法，它根本就不需要产生一个代理出来，代理的管理已经由真实角色自己完成。</p>
<h2 id="代理是有个性的"><a href="#代理是有个性的" class="headerlink" title="代理是有个性的"></a>代理是有个性的</h2><p>一个类可以实现多个接口，完成不同任务的整合，那也就是说代理类不仅仅可以实现主题接口，也可以实现其他接口完成不同的任务，而且代理的目的是在目标对象方法的基础上作增强，这种增强的本质通常就是对目标对象的方法进行拦截和过滤，例如游戏代理是需要收费的，升一级需要5元钱，这个计算功能就是代理类的个性，它应该在代理的接口中定义<br><img src="/img/01161112_LwaC.gif" alt=""><br>增加了一个IProxy接口，其作用是计算代理的费用，否则代理公司不是亏死了，我们先来看IProxy接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProxy</span> </span>&#123;</div><div class="line">	<span class="comment">//计费</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仅仅一个方法，非常简单，看<code>GamePlayerProxy</code>来的变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span>,<span class="title">IProxy</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">IGamePlayerProxy</span><span class="params">(IGamePlayer _gamePlayer)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gamePlayer = _gamePlayer;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gamePlayer.killBoss();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gamePlayer.login(user, password);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gamePlayer.upgrade();</div><div class="line">		<span class="keyword">this</span>.count();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"升级总费用是：150元"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现了IProxy接口，同时在upgrade方法中调用该方法，完成费用结算，其他的类都没有任何改动，运行结果如下：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>登录名为zhangSan 的用户 张三登录成功！</p>
<p>张三在打怪！</p>
<p>张三 又升了一级！</p>
<p>升级总费用是：150元</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>好了，代理公司也赚钱了，我的游戏也升级了，皆大欢喜。代理类不仅仅是都可以有自己的运算方法，通常的情况下代理的职责并不一定单一，它可以组合其他的真实角色，也可以实现自己的职责，比如计算费用。代理类可以为真实角色预处理消息、过滤消息、消息转发、事后处理消息等功能，当然一个代理类，可以代理多个真实角色，并且真实角色之间可以有耦合关系，读者可以自行扩展一下。</p>
<h2 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h2><p>虚拟代理(Virual Proxy)听着很复杂，其实非常简单，我们只要把代理模式的通用代码稍微修改一下就成为虚拟代理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Subject subject;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (subject == <span class="keyword">null</span>) &#123;</div><div class="line">			subject = <span class="keyword">new</span> RealSubject();</div><div class="line">		&#125;</div><div class="line">		subject.request();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在需要的时候才初始化主题对象，可以避免被代理对象较多而引起的初始化缓慢的问题，它的缺点就是需要在每个方法中判断主题对象是否被创建，这就是虚拟代理，非常简单。</p>
<p>到这里现总结一下：<br>代理模式可以提供非常好的访问控制。<br>因此一个代理类具体代理哪个真实主题角色，是由场景类决定的。<br>强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色，高层模块只要调用getProxy就可以访问真实角色的所有方法，它根本就不需要产生一个代理出来，代理的管理已经由真实角色自己完成。<br>代理类自己的个性是指：它可以有自己的方法或者实现另外的接口。<br>一个代理类可以代理多个真实角色（实现多个共同接口），然而最好不要这么做。<br>虚拟代理，创建代理的时候不进行创建，然而用的时候再进行创建—-判断试一下是否为null,为null就new 否则直接用。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>放在最后讲的一般都是压轴大戏，动态代理就是如此，上面的章节都是一个引子，动态代理才是重头戏。嘛是动态代理？动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理那一个对象，相对的来说，自己写代理类的方式就是静态代理。本章节的核心部分就在动态代理上，现在有一个非常流行的名称叫做：面向横切面编程，也就是AOP（Aspect Oriented Programming），其核心就是采用了动态代理机制，既然这么重要，我们就来看看动态代理是如何实现的，还是以打游戏为例，类图修改一下以实现动态代理。</p>
<p><img src="/img/clip_image014_2.gif" alt=""><br>在类图中增加了一个InvocationHanlder接口和GamePlayIH类，作用就是产生一个对象的代理对象，其中InvocationHanlder是JDK提供的动态代理接口，对被代理类的方法进行代理。我们来看程序，接口保持不变，实现类也没有变化，请参考前面的代码。我们来看DynamicProxy类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayIH</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">	Class cls = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	Object obj = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GamePlayIH</span><span class="params">(Object _obj)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.obj = _obj;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Ojbect[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		Object result = method.invoke(<span class="keyword">this</span>.obj, args);</div><div class="line">        <span class="keyword">return</span> result;		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中invoke方法是接口InvocationHandler定义必须实现的，它完成对真实方法的调用。我们来详细讲解一下InvocationHanlder接口，动态代理是根据被代理的接口生成所有的方法，也就是说给定一个接口，动态代理会宣称“我已经实现该接口下的所有方法了”，那各位读者想想看，动态代理怎么才能实现被代理接口中的方法呢？默认情况下所有的方法返回值都是空的，是的，代理已经实现它了，但是没有任何的逻辑含义，那怎么办？好办，通过InvocationHandler接口，所有方法都由该Handler来进行处理，即所有被代理的方法都由InvocationHandler接管实际的处理任务。</p>
<p>我们接下来看看场景类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>)；</div><div class="line"></div><div class="line">        InvocationHandler handler = <span class="keyword">new</span> GamePlayIH(player);</div><div class="line"></div><div class="line">        <span class="comment">//开始打游戏，记下时间戳</span></div><div class="line">        System.out.println(<span class="string">"开始时间是：2009-8-25 10:45"</span>);</div><div class="line"></div><div class="line">        ClassLoader cl = player.getClass().getClassLoader();</div><div class="line"></div><div class="line">        IGamePlayer proxy = (IGamePlayer)Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;IGamePlayer.class&#125;, handler);</div><div class="line"></div><div class="line">        proxy.login(<span class="string">"zhangsan"</span>, <span class="string">"password"</span>);</div><div class="line"></div><div class="line">        proxy.killBoss();</div><div class="line"></div><div class="line">        proxy.upgrade();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"结束时间是：2009-8-26 03:40"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很奇怪是吗？不要着急，学习是一个循序渐进的过程，继续看下去，我知道你的疑惑了。其运行结果如下：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>登录名为zhangSan 的用户 张三登录成功！</p>
<p>张三在打怪！</p>
<p>张三 又升了一级！</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>我们还是让代练者帮我们打游戏，但是我们既没有创建代理类，也没有实现IGamePlayer接口，这就是动态代理。别急，动态代理可不仅仅就这么多内容，还有更重要的，如果我们想在游戏登陆后发一个信息给我，防止账号被人盗用嘛，该怎么处理？直接修改被代理类GamePlayer？这不是一个好办法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayIH</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="comment">//被代理者</span></div><div class="line">     Class cls =<span class="keyword">null</span>;</div><div class="line"> </div><div class="line">     <span class="comment">//被代理的实例</span></div><div class="line">     Object obj = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">     <span class="comment">//我要代理谁</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">GamePlayIH</span><span class="params">(Object _obj)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.obj = _obj;</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     <span class="comment">//调用被代理的方法</span></div><div class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">         </div><div class="line">         Object result = method.invoke(<span class="keyword">this</span>.obj, args);</div><div class="line"> </div><div class="line">         <span class="comment">//如果是登录方法，则发送信息</span></div><div class="line">         <span class="keyword">if</span>(method.getName().equalsIgnoreCase(<span class="string">"login"</span>))&#123;</div><div class="line">              System.out.println(<span class="string">"有人在用我的账号登陆！"</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 看黑体部分，只要在代理中增加一个判断就可以决定是否要发送信息，运行结果如下：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>登录名为zhangSan 的用户 张三登录成功！</p>
<p>有人在用我的账号登陆！</p>
<p>张三在打怪！</p>
<p>张三 又升了一级！</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>That’s very nice。 有人用我的账号就发送一个信息，然后看看自己的账号是不是被人盗了，非常好的方法，这就是AOP编程，AOP编程没有使用什么新的技术，但是它对我们的设计、编码有非常大的影响，对于日志、事务、权限等都可以在系统设计阶段不用考虑，而在设计后通过AOP的方式切过去。既然动态代理是如此的诱人，我们来看看通用动态代理模型，类图如图12-7所示。<br><img src="/img/01161112_Fpoh.gif" alt=""></p>
<p>很简单，两条独立发展的线路，动态代理实现代理的职责，业务逻辑Subject实现相关的逻辑功能，两者之间没有必然的相互耦合的关系，通知Advice从另一个切面切入，最终在高层模块也就是Client进行耦合，完成逻辑的封装任务，我们先来看Subject接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">//业务操作</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String str)</span></span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的doSomething是一个标示方法，可以有多个逻辑处理方法，实现类如代码清单12-25所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="comment">//业务操作 </span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">       System.out.println(<span class="string">"do something!----&gt;"</span> + str);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点是我们的MyInvocationHandler，如代码清单12-27所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="comment">//被代理的对象</span></div><div class="line">     <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">     <span class="comment">//通过构造函数传递一个对象</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object _obj)</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.target = _obj;</div><div class="line">     &#125;</div><div class="line">    <span class="comment">//代理方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">       <span class="comment">//执行被代理的方法</span></div><div class="line">       <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.target, args);</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>非常简单，所有通过动态代理实现的方法全部通过invokve方法调用。DynamicProxy代码如代码清单12-28所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, </span></span></div><div class="line">                       Class&lt;?&gt;[] interfaces, InvocationHandler h)&#123;</div><div class="line">         <span class="comment">//寻找JoinPoint连接点，AOP框架使用元数据定义</span></div><div class="line">         <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</div><div class="line">         </div><div class="line">              <span class="comment">//执行一个前置通知</span></div><div class="line">              (<span class="keyword">new</span> BeforeAdvice()).exec();</div><div class="line">         &#125;</div><div class="line">        <span class="comment">//执行目标，并返回结果</span></div><div class="line">        <span class="keyword">return</span> (T)Proxy.newProxyInstance(loader,interfaces, h);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里插入了较多的AOP术语，在什么地方（连接点）执行什么行为（通知），我们在这里实现了一个简单的横切面编程，读者有经验的话可以看看AOP的配置文件就会明白这段代码的意义了。我们来看通知Advice，也就是我们要切入的类，比较简单，接口和实现如代码清单12-29所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAdvice</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdvice</span> <span class="keyword">implements</span> <span class="title">IAdvice</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"开是前置通知，我被执行了"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后就是看我们怎么调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="comment">//定义一个主题</span></div><div class="line">         Subject subject = <span class="keyword">new</span> RealSubject();</div><div class="line"> </div><div class="line">         <span class="comment">//定义一个Handler</span></div><div class="line">         InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(subject);</div><div class="line"> </div><div class="line">         <span class="comment">//定义主题的代理</span></div><div class="line">         Subject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(),</div><div class="line">                                            subject.getClass().getInterfaces(),handler);</div><div class="line">         <span class="comment">//代理的行为</span></div><div class="line">         proxy.doSomething(<span class="string">"Finish"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下所示：</p>
<p>我是前置通知，我被执行了！</p>
<p>do something!—-&gt;Finish</p>
<p>好，所有的程序都看完了，我们回过头来看看程序是怎么实现的。在DynamicProxy类中，我们有这样的方法：<br><code>this.obj = Proxy.newProxyInstance(c.getClassLoader(), c.getInterfaces(), new MyInvocationHandler(_obj));</code><br>该方法是重新生成了一个对象，为什么要重新生成？你要使用代理呀，注意c.getInterfaces()这句话，这是非常有意思的一句话，是说查找到该类的所有接口，然后实现接口的所有方法，当然了，方法都是空的，由谁具体负责接管呢？是new MyInvocationHandler(_Obj)这个对象，于是清楚了：一个类的动态代理类是这样的一个类，由InvocationHandler的实现类实现所有的方法，由其invoke方法接管所有方法的实现，其动态调用过程如图12-9所示。<br><img src="/img/01161112_v1d4.jpg" alt=""></p>
<p>读者可能注意到我们以上的代码还有更进一步的扩展余地，那当然了，注意看DynamicProxy类，它是一个通用类，不具有业务意义，如果我们再产生一个实现类是不是就很有意义了呢？如代码清单12-31所示。<br>代码清单12-31 具体业务的动态代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectDynamicProxy</span> <span class="keyword">extends</span> <span class="title">DynamicProxy</span></span>&#123;</div><div class="line"> </div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(Subject subject)</span></span>&#123;</div><div class="line"> </div><div class="line">          <span class="comment">//获得ClassLoader</span></div><div class="line">          ClassLoader loader = subject.getClass().getClassLoader();</div><div class="line"> </div><div class="line">          <span class="comment">//获得接口数组</span></div><div class="line">          Class&lt;?&gt;[] classes = subject.getClass().getInterfaces();</div><div class="line"> </div><div class="line">          <span class="comment">//获得handler</span></div><div class="line">          InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(subject);</div><div class="line">               <span class="keyword">return</span> newProxyInstance(loader, classes, handler);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此扩展以后，高层模块对代理的访问会更加简单，如代码清单12-32所示。</p>
<p>代码清单12-32 场景类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="comment">//定义一个主题</span></div><div class="line">         Subject subject = <span class="keyword">new</span> RealSubject();</div><div class="line"> </div><div class="line">         <span class="comment">//定义主题的代理</span></div><div class="line">         Subject proxy = SubjectDynamicProxy.newProxyInstance(subject);</div><div class="line"> </div><div class="line">         <span class="comment">//代理的行为</span></div><div class="line">         proxy.doSomething(<span class="string">"Finish"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是不是更加简单了？可能读者就要提问了，这样与静态代理还有什么区别？都是需要实现一个代理类，有区别，注意看父类，动态代理的主要意图就是解决我们常说的“审计”问题，也就横切面编程，在不改变我们已有代码结构的情况下增强或控制对象的行为。</p>
<p>注意 要实现动态代理的首要条件是：被代理类必须实现一个接口，回想一下刚刚的分析吧。当然了，现在也有很多技术如CGLIB可以实现不需要接口也可以实现动态代理的方式。</p>
<p>再次说明，以上的动态代理是一个通用代理框架，如果你想设计自己的AOP框架，完全可以在此基础上扩展，我们设计的是一个通用代理，只要有一个接口，一个实现类，就可以使用该代理，完成代理的所有功效。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>代理模式应用的非常广泛，大到一个系统框架、企业平台，小到代码片段、事务处理，稍不留意就用到代理模式，可能该模式是大家接触最多的模式，而且有了AOP大家写代理就更加简单了，有类似Spring AOP和AspectJ这样非常优秀的工具，拿来主义即可，我们还自己写代理干嘛！不过，大家可以看看源代码，特别是调试时，只要看到类似$Proxy0这样的结构，你就应该知道这是一个动态代理了。<br>友情提醒，在学习AOP框架时，弄起初几个名词就成：切面（Aspect）、切入点(JoinPoint)、通知（Advice）、织入（Weave）就足够了，理解了这几个名词，你就可以对AOP游刃有余了！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[装饰器模式]]></title>
      <url>http://iliubang.github.io/2017/02/09/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="装饰器模式概述"><a href="#装饰器模式概述" class="headerlink" title="装饰器模式概述"></a>装饰器模式概述</h1><p>装饰器模式能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象设计中，而我们应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。总之，装饰器模式是通过把复杂的功能简单化，分散化，然后再运行起见，根据需要来动态组合的这样一个模式。<br><a id="more"></a></p>
<h1 id="模式结构说明"><a href="#模式结构说明" class="headerlink" title="模式结构说明"></a>模式结构说明</h1><p>装饰器模式的结构如下图:<br><img src="/img/2017020904.jpg" alt="装饰器模式类图"></p>
<p><code>Component</code>：组件对象的接口，可以给这些对象动态添加职责；<br><code>ConcreteComponent</code>：具体的组件对象实现了组件接口。该对象通常就是被装饰器装饰的原始对象，可以给这个对象添加职责；<br><code>Decorator</code>：所有装饰器的基类，需要定义一个与组件接口一致的接口（主要是为了实现装饰器的功能的复用，即具体的装饰器<code>A</code>可以装饰另外一个具体的装饰器<code>B</code>，因为装饰器类也是一个<code>Component</code>），并持有一个<code>Component</code>对象，改对象其实就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。<br><code>ConcreteDecorator</code>：具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>(1) 组件对象的接口，可以给这些对象动态添加职责</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(2) 具体实现组件对象接口的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//具体操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(3) 装饰器接口，维持一个指向组件对象的接口对象，并定义一个与组件接口一致的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> Component component;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.component = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//妆发请求给组件对象，可以在转发前后执行一些附加动作</span></div><div class="line">        component.operation();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(4) 装饰器的具体实现对象，向组件对象添加职责，<code>operationFirst()</code>,<code>operationLast()</code>为前后需要添加的功能。具体的装饰器类<code>ConcreteDecoratorB</code>代码相似，不再给出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">operationFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">operationLast</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        operationFirst();</div><div class="line">        <span class="keyword">super</span>.operation();</div><div class="line">        operationLast();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(5) 客户端使用装饰器的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建需要被装饰器装饰的原始对象</span></div><div class="line">        Component c1 = <span class="keyword">new</span> ConcreteComponent();</div><div class="line">        <span class="comment">//给对象透明的增加功能A并调用</span></div><div class="line">        Decorator decoratorA = <span class="keyword">new</span> ConcreteDecoratorA(c1);</div><div class="line">        decoratorA.operation();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[适配器模式]]></title>
      <url>http://iliubang.github.io/2017/02/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="适配器模式概述"><a href="#适配器模式概述" class="headerlink" title="适配器模式概述"></a>适配器模式概述</h1><p>在计算机编程中，适配器(adapter)模式(有时候也称包装样式或者包装)将一个类的接口适配称用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。<br><a id="more"></a></p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol>
<li>已存在的类接口不符合我们的需求。</li>
<li>创建一个可以复用的类，使得该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作。</li>
<li>在不对每一个都进行子类化以匹配他们的几口的情况下，使用一些已经存在的子类。</li>
</ol>
<h1 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h1><p><img src="/img/2017020902.jpg" alt="适配器模式类图"></p>
<p>电源适配器，他是用于电流变换（整流）的设备。适配器的存在，就是为了将已存在的东西（接口）转换成适合我们的需求，能被我们所利用。在现实生活中，适配器更多的是作为一个中间层来实现这种转换作用。<br>在上面的通用类图中，<code>Client</code>类最终面对的是<code>Target</code>接口（或抽象类），它知识能够使用符合这一目标标准的子类；而<code>Adapter</code>类则是被适配的对象（也称源角色），因为它包含<code>specific</code>（特殊的）操作，功能等，所以我们想要在自己的系统中使用它，将其转换成符合我们标准的类，使得<code>Client</code>类可以在透明的情况下任意选择使用<code>Concrete Target</code>类或是具有特殊功能的<code>Adatee</code>类。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//已存在的，具有特殊功能的，但是不符合既有的标准接口的类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"被适配类具有特殊功能..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//目标接口，或称为标准接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体目标类，只提供普通功能</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span>  </span>&#123;</div><div class="line">        System.out.println(<span class="string">"普通类，具有普通功能..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//适配器类，继承了被适配类，同时实现了标准接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function">publc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//使用普通类功能</span></div><div class="line">        Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</div><div class="line">        concreteTarget.request();</div><div class="line">        <span class="comment">//使用特殊功能，即适配类</span></div><div class="line">        Target adapter = <span class="keyword">new</span> Adapter();</div><div class="line">        adapter.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种实现的适配器称为类适配器，因为<code>Adapter</code>类既继承了<code>Adaptee</code>（被适配类），也实现了<code>Target</code>接口（因为java不支持多继承，所以这样来实现），在<code>Client</code>类中我们可以根据需要选择并创建任意一种符合要求的子类，来实现具体功能。</p>
<p>另外一种适配器模式是对象适配器，它不是使用多继承或继承再实现的方式，而是使用直接关联，或者成为委托的方式，类图如下：<br><img src="/img/2017020903.jpg" alt="对象适配器模式类图"></p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//适配器类，直接关联被适配类，同时实现标准接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="comment">//直接关联被适配类</span></div><div class="line">    <span class="keyword">private</span> Adaptee adaptee;</div><div class="line"></div><div class="line">    <span class="comment">//可以通过构造函数传入具体需要适配的被适配对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee.specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//使用普通类</span></div><div class="line">        Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</div><div class="line">        concreteTarget.request();</div><div class="line">        <span class="comment">//使用特殊功能</span></div><div class="line">        Target adapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</div><div class="line">        adapter.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a>适配器模式的优缺点</h1><p><strong>优点</strong><br>适配器模式也是一种包装模式，对象适配器模式还有委托的意思。总的来说适配器模式属于补偿模式，专用来在系统后期扩展，修改时使用。</p>
<p><strong>缺点</strong><br>过多的使用适配器，会让系统非常凌乱，不易整体进行把握。比如，明明看到调用的是<code>A</code>接口，其实内部被适配称了<code>B</code>接口的实现，一个系统如果出现太多的这种情况，无异于异常灾难。因此如果不是很有必要，可以不适用适配器，而是直接对系统重构。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[原型模式]]></title>
      <url>http://iliubang.github.io/2017/02/09/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="原型模式概述"><a href="#原型模式概述" class="headerlink" title="原型模式概述"></a>原型模式概述</h1><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br>原型模式(prototype)是一种创建型设计模式，它允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节，工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们来实施创建。<br>原型模式主要解决的问题是：某些结构复杂的对象创建工作。由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。<br><a id="more"></a></p>
<p><img src="/img/2017020901.jpg" alt="原型模式类图"></p>
<p>原型模式主要用于对象的复制，他的核心就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：</p>
<ul>
<li>实现<code>Cloneable</code>接口。在java语言中有一个<code>Cloneable</code>接口，它的作用只有一个，就是在运行时通知虚拟机可以安全的在实现了此接口的类上使用<code>clone</code>方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出<code>CloneNotSupportedException</code>异常。</li>
<li>重写<code>Object</code>类中的<code>clone</code>方法。java中，所有类的基类都是<code>Object</code>类，其中有一个<code>clone</code>方法，作用是返回对象的一个拷贝，但是其作用域是protected类型，一般的类无法调用，因此，<code>Prototype</code>类需要将<code>clone</code>改为public类型。</li>
</ul>
<h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Prototype prototype = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            prototype = (Prototype)<span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"运行模式实现"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</div><div class="line">        ConcretePrototype cp = <span class="keyword">new</span> ConcretePrototype();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&gt;) &#123;</div><div class="line">            ConcretePrototype clonecp = (ConcretePrototype)cp.clone();</div><div class="line">            clonecp.show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="原型模式的优点和应用场景"><a href="#原型模式的优点和应用场景" class="headerlink" title="原型模式的优点和应用场景"></a>原型模式的优点和应用场景</h1><p>使用原型模式创建对象比直接new一个对象在性能上好的多，因为<code>Object</code>类的<code>clone</code>方法是一个native方法，它直接操作内存中的二进制流，特别是复制大对象时，性能差别非常明显。<br>使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档的复制粘贴一样简单。<br>因为以上优点，所以在需要重复创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式可以简化创建过程，而且提高性能。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>使用原型模式创建对象不会调用类的构造方法。因为对象的复制是直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。也即是说，即使构造方法为private，也可以使用<code>clone</code>来创建对象。</li>
<li>深拷贝和浅拷贝。<code>Object</code>类中的<code>clone</code>方法只会拷贝对象中的基本数据类型，对于数组，容器对象，引用对象都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型中的数组，容器对象，引用对象等另行拷贝。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList list = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Prototype prototype = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            prototype = (Prototype)<span class="keyword">super</span>.clone();</div><div class="line">            prototype.list = (ArrayList)<span class="keyword">this</span>.list.cone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[建造者模式]]></title>
      <url>http://iliubang.github.io/2017/02/08/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="建造者模式概述"><a href="#建造者模式概述" class="headerlink" title="建造者模式概述"></a>建造者模式概述</h1><p>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。<br><a id="more"></a></p>
<h1 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h1><ol>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时。</li>
<li>当构造过程必须允许被构造的对象有不同表示时。</li>
</ol>
<p><img src="/img/2017020801.jpg" alt="建造者模式类图"></p>
<h1 id="四个要素"><a href="#四个要素" class="headerlink" title="四个要素"></a>四个要素</h1><ul>
<li>产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类途中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与他的不同实现组成，也可以是由多个抽象类与他们的实现组成。</li>
<li>抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交给它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个用来返回产品。</li>
<li>建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。</li>
<li>导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演被用来封装程序中易变的部分。</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> String type;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"名称："</span> + name);</div><div class="line">        System.out.println(<span class="string">"型号："</span> + type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPar</span><span class="params">(String arg1, String arg2)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        product.setName(arg1);</div><div class="line">        product.setType(arg2);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">new</span> ConcreteBuilder();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getAProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        builder.setPart(<span class="string">"宝马"</span>, <span class="string">"X7"</span>);</div><div class="line">        <span class="keyword">return</span> builder.getProduct();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getBProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        builder.setPart(<span class="string">"奥迪"</span>, <span class="string">"Q7"</span>);</div><div class="line">        <span class="keyword">return</span> builder.getProduct();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Director director = <span class="keyword">new</span> Director();</div><div class="line">        Product product1 = director.getAProduct();</div><div class="line">        product1.showProduct();</div><div class="line">        Product product2 = director.getBProduct();</div><div class="line">        product2.showProduct();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h1><p>首先，建造者模式的封装性很好，使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。<br>其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。</p>
<h1 id="建造者模式与工厂模式的区别"><a href="#建造者模式与工厂模式的区别" class="headerlink" title="建造者模式与工厂模式的区别"></a>建造者模式与工厂模式的区别</h1><p>我们可以看到，建造者模式与工厂模式极为相似，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，加入把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看做是一个简单的工厂模式了。<br>与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类–导演类。也就是说，工厂模式是将对象的全部创建过程封装在了工厂中了，有工厂类想客户端提供终端产品；而建造者模式中，建造者类一般只提供产品中各个组件的装配，而将具体建造过程交给导演。由导演负责将各个组件按照特定的规则组件成产品，然后交付给客户端。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单例模式]]></title>
      <url>http://iliubang.github.io/2017/02/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="单例模式概述"><a href="#单例模式概述" class="headerlink" title="单例模式概述"></a>单例模式概述</h1><p>单例模式是一种常用的软件设计模式。在他的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。<br>数学和逻辑学中，singleton定义为“有且仅有一个元素的集合”.<br>单例模式最初的定义出现在《设计模式》（艾迪生维斯理，1994）：“保证一个类仅有一个实例，并提供一个访问它的全局访问点。”<br><a id="more"></a></p>
<h1 id="基本实现思路"><a href="#基本实现思路" class="headerlink" title="基本实现思路"></a>基本实现思路</h1><p>单例模式要求能够有返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）<br>单例的实现主要是通过以下两个步骤：</p>
<ol>
<li>将该类的构造方法私有化，这样其他处理的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类唯一的实例；</li>
<li>在该类内部提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果为空就创建该类的实例并将其赋值给该类持有的引用。</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>单例模式在多线程的应用场合下必须小心使用，如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么他们同时没有检测到唯一实例的存在，从而各自创建一个实例，这样就有两个实例被创建出来，从而违反了单例模式中实例唯一的原则。解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁（虽然这样会降低效率）</p>
<h1 id="单例模式的8种写法"><a href="#单例模式的8种写法" class="headerlink" title="单例模式的8种写法"></a>单例模式的8种写法</h1><h2 id="饿汉式（静态常亮）"><a href="#饿汉式（静态常亮）" class="headerlink" title="饿汉式（静态常亮）"></a>饿汉式（静态常亮）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步的问题。<br>缺点：在类装载完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<h2 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式和上面的方式其实类似，只不过将实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面一样。</p>
<h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了<code>if(singleton == null)</code>判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时就会产生多个实例。所以在多线程下不可使用这种方式。</p>
<h2 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决上面第三种实现方式线程不安全问题，做个线程同步就可以了，于是就对<code>getInstance</code>方法进行了线程同步。<br>缺点：效率太低了，每个线程想获得类的实例的时候，执行<code>getInstance</code>方法都要进行同步。而其实这个方法只执行一次实例代码就够了，后面想获得实例，就直接<code>return</code>就行了。方法进行同步效率太低要改进。</p>
<h2 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</div><div class="line">                singleton = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的代码块。但是这种同步的方式不能起到线程同步的作用。跟第三种实现方式遇到的清醒一致，假如一个线程进入了判断语句，还没有来得及往下执行另一个线程也通过了判断，这时候就会产生多个实例。</p>
<h2 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">                    singleton = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次<code>if (singleton == null)</code>的判断，这样就可以保证线程安全了。这样实例化代码只用执行一次，后面再次访问时候直接<code>return</code>掉。<br>优点：线程安全；延迟加载；效率较高。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法跟饿汉式采用的机制类似，但又不同。两者都是采用了类装载机制来保证初始化实例的时候只有一个线程。不同的是饿汉式是在类装载的时候实例化，而静态内部类的方式在Singleton类被装载的时候不会立即实例化，而是在调用getInstance方法时才会装载SingletonInstance类，从而完成单例。<br>优点：线程安全，延迟加载，效率高。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然单例模式有这么多写法，但是其核心思想是不变的，即保证一个类有且仅有一个实例对象，在实际的开发中，我们应该结合场景选择合适的一种。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[工厂设计模式]]></title>
      <url>http://iliubang.github.io/2017/02/07/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="工厂模式概述"><a href="#工厂模式概述" class="headerlink" title="工厂模式概述"></a>工厂模式概述</h1><p>工厂(Factory Pattern)模式是Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p><img src="/img/2017020701.jpg" alt="uml图"></p>
<a id="more"></a>
<p>下面来看一个小小的栗子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operate)</span> </span>&#123;</div><div class="line">    Operation op = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">switch</span>(operate) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"+"</span>:</div><div class="line">            op = <span class="keyword">new</span> OperationAdd();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"-"</span>:</div><div class="line">            op = <span class="keyword">new</span> OperationSub();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"*"</span>:</div><div class="line">            op = <span class="keyword">new</span> OperationMul();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"/"</span>:</div><div class="line">            op = <span class="keyword">new</span> OperationDiv();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> op;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优点：客户端不需要修改代码<br>缺点：当需要增加新的运算类的时候，不仅需新加运算类，还要修改工厂类，违反了开闭原则。</p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。<br><img src="/img/2017020702.jpg" alt="uml图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Shape.java</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Rectangle.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Rectangle::draw() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Square.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Square::draw() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Circle.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Circle::draw() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Color.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Red.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Red::fill() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Green.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Green::fill() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Blue.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Blue::fill() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//为Color和Shape对象创建抽象类来获取工厂</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> class <span class="title">AbstractFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建扩展了AbstractFactory的工厂类，基于给定的信息生成实体类的对象。</span></div><div class="line"><span class="comment">//ShapeFactory</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (shape == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (shape.equalsIgnoreCase(<span class="string">"circle"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equalsIgnoreCase(<span class="string">"square"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equalsIgnoreCase(<span class="string">"rectangle"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ColorFactory</span></div><div class="line">publicc <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbastractFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (color == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"red"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Red();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"green"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Green();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"blue"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> blue();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>http://iliubang.github.io/2017/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式(design patterns)是一套被反复使用、多数人知晓的、经过分类编目的代码设计经验总结。使用设计模式是为了可重用代码、让代码更容易被他人理解，保证代码的可靠性。毫无疑问，设计模式于己于人都是有利的。设计模式使代码编制真正工程化，设计模式是软件工程的基石，如通大厦的一块砖石一样。项目中合理运用设计模式可以完美的解决很多问题，每种设计模式在现在中都有相应的原理与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p>
<a id="more"></a>
<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五中：</p>
<ul>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>单例模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ul>
<p>结构型模式，共七种：</p>
<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<p>行为型模式，共十一种类：</p>
<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代子模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
<p>其实还有两类：并发型模式和线程池模式</p>
<h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><p><strong>1. 开闭原则(Open Close Principle)</strong><br>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行扩展的时候，不能修改原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p>
<p><strong>2. 里氏替换原则(Liskov Substitution Principle)</strong><br>里氏替换原则(Liskov Substitution Principle LSP)是面向对象设计的基本原则之一。里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏替换原则是对“开闭原则”的补充。实现“开闭原则”的关键步骤是抽象化。而基类与衍生类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3. 依赖倒转原则(Dependence Inversion Principle)</strong><br>这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4. 接口隔离原则(Interface Segregation Principle)</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间耦合度的意思。从这里我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。</p>
<p><strong>5. 迪米特法则(最少了解原则)(Demeter Principle)</strong><br>定义：一个对象应该对其他对象保持最少的了解，从而使得功能模块相对独立。</p>
<p><strong>6. 合成复用原则(Composite Reuse Principle)</strong><br>尽量使用合成/聚合的方式，而不使用继承。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于C语言的编程语言开发yacc_lex初步]]></title>
      <url>http://iliubang.github.io/2017/02/06/%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91yacc-lex%E5%88%9D%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>当今世道，各种高级语言百花齐放。然而会有人发出这样的疑问–计算机真的能够识别这么多语言吗？稍微有点常识的人都知道，这显然是不可能滴！在计算机的世界里，他们能够直接识别的只有机器语言。然而，由于机器语言对人类不够友好，所以人们才发明了汇编，c，Java…许许多多的人类易读的编程语言，所以我个人对编程语言的理解一直是其实他们就是机器语言的语法糖，而编程语言的创造过程，就是定义一种合理的，没有二义性的语法规则，然后就是通过直接或间接的方式实现该语法到机器语言的转换过程。既然是这样的话，那么我们就很容易想到，计算机语言是一个自我完善的过程：首先我们定了一种非常简单的x1(这里只是用来举例说明，有没有x语言有待考证)语言，然后用机器语言实现了这个非常简单的x1语言的编译器，创造了x1语言，实现了非常简单的新特性，然后我们再用x1语言(相对于机器语言较高级)实现了另一些新的特性的x2语言的编译器，创造了x2语言，…<a id="more"></a>，如此下去，人们创造了汇编语言，从而创造了c语言，接着创造了世界上最好的语言PHP(不知道是不是真的，反正大家都习惯这么说)。<br>在各种高级语言越来越强大的今天，我们可能很难再会去接触最原始的东西，高度封装确实提高了生产力，降低了学习成本，但是也使得现代程序员将太多精力花在了各种说明书上，而不清楚其本质。<br>毕业一年多，工作了一年多，对于计算机编程有了自己的看法，不再像在大学的时候认识的那样肤浅，反而觉得大学中学习的知识才是真正的干货，不禁感叹曾经浪费掉了大好光阴。好在陶渊明有词云：“悟已往之不谏，知来者之可追”。<br>闲暇之余，扒开PHP(这里之所以是PHP并不因为他是世界上最好的语言，只是因为我目前从事的是PHP开发的工作而已)源码，了解了其内部构造和实现原理，百看不一练。今天就初步学习yacc/lex了，记录在我的博客中，以便以后翻阅巩固。</p>
<h1 id="过程简述"><a href="#过程简述" class="headerlink" title="过程简述"></a>过程简述</h1><p>一般来说编程语言的解释执行过程如下：</p>
<p><strong>ONE</strong>. 词法分析<br>将源代码拆分成若干Token的过程</p>
<p><strong>TWO</strong>.语法分析<br>将Token构建成Syntax Tree的过程</p>
<p><strong>THREE</strong>.生成执行码<br>生成可执行文件</p>
<h1 id="yacc（Yet-Another-Compiler-Compiler）"><a href="#yacc（Yet-Another-Compiler-Compiler）" class="headerlink" title="yacc（Yet Another Compiler Compiler）"></a>yacc（Yet Another Compiler Compiler）</h1><p>下面是wikipedia中对yacc的描述</p>
<blockquote>
<p>Yacc is a computer program for the Unix operating system. It is a Look Ahead Left-to-Right (LALR) parser generator, generating a parser, the part of a compiler that tries to make syntactic sense of the source code, specifically a LALR parser, based on an analytic grammar written in a notation similar to Backus–Naur Form (BNF). Yacc itself used to be available as the default parser generator on most Unix systems, though it has since been supplanted as the default by more recent, largely compatible, programs.</p>
</blockquote>
<p>其安装非常简单</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install bison</div></pre></td></tr></table></figure>
<h1 id="lex-flex"><a href="#lex-flex" class="headerlink" title="lex/flex"></a>lex/flex</h1><p>lex 是一个生成词法分析器的工具。Lex读进一个代表词法分析器规则的输入字符串流，然后输出以C语言实做的词法分析器源代码。传统上，lex属于商业软件，但是有些根据原本AT&amp;T代码这些版本的Lex可以以公开源代码的形式获得，并被视为某些系统的一部分，例如说OpenSolaris和贝尔实验室九号项目。另一个有名的Lex公开源代码版本是flex，代表”快速的词法分析器”（fast lexical analyzer）</p>
<p>在linux下安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install flex</div></pre></td></tr></table></figure>
<h1 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h1><ul>
<li>实现一个简单的计算程序</li>
</ul>
<p>首先定义lex规则，其扩展名为<code>.l</code>，在lex中可以很容易读懂其定义的规则，因为他用到的是正则表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">%&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"y.tab.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">yywrap</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">%&#125;</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line"><span class="string">"+"</span>		<span class="keyword">return</span> ADD;</div><div class="line"><span class="string">"-"</span>		<span class="keyword">return</span> SUB;</div><div class="line"><span class="string">"*"</span>		<span class="keyword">return</span> MUL;</div><div class="line"><span class="string">"/"</span>		<span class="keyword">return</span> DIV;</div><div class="line"><span class="string">"\n"</span>		<span class="keyword">return</span> CR;</div><div class="line"></div><div class="line">([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)|<span class="number">0</span>|([<span class="number">0</span><span class="number">-9</span>]+\.[<span class="number">0</span><span class="number">-9</span>]+) &#123;</div><div class="line">	<span class="keyword">double</span> d;</div><div class="line">	<span class="built_in">sscanf</span>(yytext, <span class="string">"%lf"</span>, &amp;d);</div><div class="line">	yylval.double_value = d;</div><div class="line">	<span class="keyword">return</span> DOUBLE_LITERAL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">[ \t] ;</div><div class="line">. &#123;</div><div class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"lexical error.\n"</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">%%</div></pre></td></tr></table></figure>
<p>可以看到以上的代码主要包含两部分，<code>%{</code> <code>%}</code>包含的部分和<code>%%</code> <code>%%</code>包含的部分。前一部分叫<strong>定义区块</strong>, 后者是<strong>规则区块</strong>，定义区块内的代码将会被原样输出，在定义区块中<code>#include &quot;y.tab.h&quot;</code>将会在yacc编译其规则文件后自动生成，<code>ADD</code> <code>SUB</code> <code>MUL</code> <code>DIV</code> <code>CR</code> <code>DOUBLE_LITERAL</code>等都是在y.tab.h中定义的macro。<br>在定义区块中，有一个名为<code>yywrap</code>的function，其作用是自动link lex的库文件。<br>至于规则区块，学过正则表达式的人一看就会明白，其作用就是使用正则表达式来描述Token。规则区块的定义为：正则表达式，后边跟上C代码，这些代码用<code>{}</code>括起来，读入的字符流满足了正则，则执行其后的代码，匹配到的原字符被保存在<code>yytext</code>这个全局变量中。</p>
<p>接着来编写yacc的规则，其扩展名为<code>.y</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">%&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> YYDEBUG 1</span></div><div class="line"></div><div class="line">%&#125;</div><div class="line"></div><div class="line">%<span class="keyword">union</span> &#123;</div><div class="line">	<span class="keyword">int</span>	int_value;</div><div class="line">	<span class="keyword">double</span>	double_value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">%token &lt;double_value&gt;		DOUBLE_LITERAL</div><div class="line">%token ADD SUB MUL DIV CR</div><div class="line">%type &lt;double_value&gt; expression term primary_expression</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">line_list</div><div class="line">	: line</div><div class="line">	| line_list line</div><div class="line">;</div><div class="line">line</div><div class="line">	: expression CR</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"&gt;&gt;%lf\n"</span>, $<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">expression</div><div class="line">	: term</div><div class="line">	| expression ADD term</div><div class="line">	&#123;</div><div class="line">		$$ = $<span class="number">1</span> + $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">	| expression SUB term</div><div class="line">	&#123;</div><div class="line">		$$ = $<span class="number">1</span> - $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">term</div><div class="line">	: primary_expression</div><div class="line">	| term MUL primary_expression</div><div class="line">	&#123;</div><div class="line">		$$ = $<span class="number">1</span> * $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">	| term DIV primary_expression</div><div class="line">	&#123;</div><div class="line">		$$ = $<span class="number">1</span> / $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">primary_expression</div><div class="line">	: DOUBLE_LITERAL</div><div class="line">;</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">yyerror</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">extern</span> <span class="keyword">char</span> *yytext;</div><div class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"syntax error near %s\n"</span>, yytext);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">yyparse</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">	<span class="keyword">extern</span> FILE *yyin;</div><div class="line"></div><div class="line">	yyin = <span class="built_in">stdin</span>;</div><div class="line">	<span class="keyword">if</span> (yyparse()) &#123;</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Core Dump!\n"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>yacc规则定义跟lex相似，都用到了<code>\%{\%}</code> <code>%%</code>来包含代码块。<br>同样的是<code>\%{\%}</code>包裹的代码将被原样输出。<br>在<code>%union</code>定义中，声明了记号和非终结符的类型，其最终会被编译成一个c语言的union。这里定义了一个int 类型的<code>int_value</code> 和 double类型的<code>double_value</code>。<br><code>%token</code>开头的行是Token的声明，所有用到的Token类型都在这里定义。对于<code>ADD</code> <code>SUB</code> <code>MUL</code> <code>DIV</code> <code>CR</code>等记号只需要包含其类型即可，而对于值为<code>DOUBLE_LITERAL</code>的Token，其类型被指定为<code>&lt;double_value&gt;</code>，这里的double_value正是来自于前面声明的union中的成员之一。<br><code>%%</code>包裹的部分叫做规则区块，由语法规则和C语言编写的相应的行为两部分构成。在yacc中使用了类似于BNF范式来编写语法规则。由于使用了自然语言作为标记，理解上还是很容易的。下面举个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">line_list                 <span class="comment">/* 多行规则 */</span></div><div class="line">	: line                  <span class="comment">/* 单行 */</span></div><div class="line">	| line_list line        <span class="comment">/* 或者多行后跟单行 */</span></div><div class="line">;</div><div class="line">line                       <span class="comment">/* 单行 */</span></div><div class="line">	: expression CR          <span class="comment">/* 表达式后跟换行符 */</span></div><div class="line">;</div><div class="line">expression                 <span class="comment">/* 表达式 */</span></div><div class="line">	: term                   <span class="comment">/* 和项 */</span></div><div class="line">	| expression ADD term    <span class="comment">/* 或者表达式加上和项 */</span></div><div class="line">	&#123;                        <span class="comment">/* 匹配后执行的action */</span></div><div class="line">		$$ = $<span class="number">1</span> + $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">	| expression SUB term    <span class="comment">/* 或者表达式减去和项 */</span></div><div class="line">	&#123;                        <span class="comment">/* 匹配后执行的action */</span></div><div class="line">		$$ = $<span class="number">1</span> - $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">term                        <span class="comment">/* 和项 */</span></div><div class="line">	: primary_expression      <span class="comment">/* 一元表达式 */</span></div><div class="line">	| term MUL primary_expression <span class="comment">/* 或者和项乘以一元表达式 */</span></div><div class="line">	&#123;                          <span class="comment">/* 匹配后执行的action */</span></div><div class="line">		$$ = $<span class="number">1</span> * $<span class="number">3</span>;</div><div class="line">	&#125;                          </div><div class="line">	| term DIV primary_expression <span class="comment">/* 或者和项除以一元表达式 */</span></div><div class="line">	&#123;                             <span class="comment">/* 匹配后执行的action */</span></div><div class="line">		$$ = $<span class="number">1</span> / $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">primary_expression          <span class="comment">/* 一元表达式 */</span></div><div class="line">	: DOUBLE_LITERAL          <span class="comment">/* 实数字面量 */</span></div><div class="line">;</div></pre></td></tr></table></figure>
<p>写好了规则，那么就来编译运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yacc -dv foo.y</div><div class="line">flex foo.l</div><div class="line">gcc -std=c99 -Wall -g -o foo y.tab.c lex.yy.c</div></pre></td></tr></table></figure>
<p>这样就生成了<code>foo</code>这个可执行文件<br>运行foo</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">liubang@venux:~/workspace/c/my_lang/lex$ make run</div><div class="line">1 + 3</div><div class="line">&gt;&gt;4.000000</div><div class="line">1/2 </div><div class="line">&gt;&gt;0.500000</div><div class="line">4 * 5</div><div class="line">&gt;&gt;20.000000</div></pre></td></tr></table></figure>
<p>当然我个人在开发c程序的时候偏向于使用make工具来编译代码，这样会很方便。下面是我的Makefile文件:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">CFLAGS = -O2 -g -Wall -std=c99</div><div class="line">EXEC = foo</div><div class="line">OBJS =	y.tab.o \</div><div class="line">	lex.yy.o</div><div class="line"></div><div class="line"></div><div class="line">%.c:</div><div class="line">	yacc -dv foo.y</div><div class="line">	lex foo.l</div><div class="line"></div><div class="line">%.o: %.c</div><div class="line">	 <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o $@ -c $&lt;</div><div class="line"></div><div class="line">$(EXEC): $(OBJS)</div><div class="line">	<span class="variable">$(CC)</span> <span class="variable">$(OBJS)</span> -o $@</div><div class="line"></div><div class="line">all: $(EXEC)</div><div class="line"></div><div class="line">run: $(EXEC)</div><div class="line">	@./<span class="variable">$(EXEC)</span></div><div class="line"></div><div class="line"><span class="section">clean:</span></div><div class="line">	<span class="variable">$(RM)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(EXEC)</span></div></pre></td></tr></table></figure>
<p>只需要执行<code>make run</code>命令即可运行！</p>
<h1 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h1><p>可能有人会疑惑，这玩意学着有什么用，那么有兴趣的你可以下载一份PHP的源代码，在Zend(Zend引擎核心文件)目录中你不难找到<code>zend_language_scanner.l</code>,<code>zend_ini_scanner.l</code>,<code>zend_ini_parser.y</code>,<code>zend_language_parser.y</code>这几个文件，打开其内容，是不是不再那么恐惧和陌生了呢。</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>本文只是初步介绍yacc/lex工具生成词法解析器和语法解析器的最基本用法，没有太多的阐述词法解析的原理和过程，所以更偏实践，再由于本人毕业一年多实在很久没写文章了，常常会提笔不知从何说起，所以写起来很慢，加之白天要工作，时间较紧，所以今天就到这里了，至于理论的阐述，需要时间来慢慢酝酿😂！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Demo]]></title>
      <url>http://iliubang.github.io/2017/02/06/Demo/</url>
      <content type="html"><![CDATA[<p>this is my demo document.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="title">foo</span></div><div class="line"></div><div class="line"><span class="title">class</span> <span class="title">App</span> &#123;</div><div class="line">    </div><div class="line">    <span class="title">private</span> <span class="title">static</span> $<span class="title">instance</span> = <span class="title">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;    </div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>::$instance <span class="keyword">instanceof</span> <span class="keyword">self</span>) &#123;</div><div class="line">            <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="test-math"><a href="#test-math" class="headerlink" title="test math"></a>test math</h2><p>这是测试用的$\lambda$</p>
<p>$$\frac{\partial u}{\partial t}<br>= h^2 \left( \frac{\partial^2 u}{\partial x^2} +<br>\frac{\partial^2 u}{\partial y^2} +<br>\frac{\partial^2 u}{\partial z^2}\right)$$</p>
<p>$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$</p>
]]></content>
    </entry>
    
  
  
</search>
