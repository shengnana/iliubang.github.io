<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[装饰器模式]]></title>
      <url>http://iliubang.github.io/2017/02/09/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="装饰器模式概述"><a href="#装饰器模式概述" class="headerlink" title="装饰器模式概述"></a>装饰器模式概述</h1><p>装饰器模式能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象设计中，而我们应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。总之，装饰器模式是通过把复杂的功能简单化，分散化，然后再运行起见，根据需要来动态组合的这样一个模式。<br><a id="more"></a></p>
<h1 id="模式结构说明"><a href="#模式结构说明" class="headerlink" title="模式结构说明"></a>模式结构说明</h1><p>装饰器模式的结构如下图:<br><img src="/img/2017020904.jpg" alt="装饰器模式类图"></p>
<p><code>Component</code>：组件对象的接口，可以给这些对象动态添加职责；<br><code>ConcreteComponent</code>：具体的组件对象实现了组件接口。该对象通常就是被装饰器装饰的原始对象，可以给这个对象添加职责；<br><code>Decorator</code>：所有装饰器的基类，需要定义一个与组件接口一致的接口（主要是为了实现装饰器的功能的复用，即具体的装饰器<code>A</code>可以装饰另外一个具体的装饰器<code>B</code>，因为装饰器类也是一个<code>Component</code>），并持有一个<code>Component</code>对象，改对象其实就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。<br><code>ConcreteDecorator</code>：具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>(1) 组件对象的接口，可以给这些对象动态添加职责</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(2) 具体实现组件对象接口的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//具体操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(3) 装饰器接口，维持一个指向组件对象的接口对象，并定义一个与组件接口一致的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> Component component;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.component = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//妆发请求给组件对象，可以在转发前后执行一些附加动作</span></div><div class="line">        component.operation();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(4) 装饰器的具体实现对象，向组件对象添加职责，<code>operationFirst()</code>,<code>operationLast()</code>为前后需要添加的功能。具体的装饰器类<code>ConcreteDecoratorB</code>代码相似，不再给出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">operationFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">operationLast</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">        operationFirst();</div><div class="line">        <span class="keyword">super</span>.operation();</div><div class="line">        operationLast();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(5) 客户端使用装饰器的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建需要被装饰器装饰的原始对象</span></div><div class="line">        Component c1 = <span class="keyword">new</span> ConcreteComponent();</div><div class="line">        <span class="comment">//给对象透明的增加功能A并调用</span></div><div class="line">        Decorator decoratorA = <span class="keyword">new</span> ConcreteDecoratorA(c1);</div><div class="line">        decoratorA.operation();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[适配器模式]]></title>
      <url>http://iliubang.github.io/2017/02/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="适配器模式概述"><a href="#适配器模式概述" class="headerlink" title="适配器模式概述"></a>适配器模式概述</h1><p>在计算机编程中，适配器(adapter)模式(有时候也称包装样式或者包装)将一个类的接口适配称用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。<br><a id="more"></a></p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol>
<li>已存在的类接口不符合我们的需求。</li>
<li>创建一个可以复用的类，使得该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作。</li>
<li>在不对每一个都进行子类化以匹配他们的几口的情况下，使用一些已经存在的子类。</li>
</ol>
<h1 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h1><p><img src="/img/2017020902.jpg" alt="适配器模式类图"></p>
<p>电源适配器，他是用于电流变换（整流）的设备。适配器的存在，就是为了将已存在的东西（接口）转换成适合我们的需求，能被我们所利用。在现实生活中，适配器更多的是作为一个中间层来实现这种转换作用。<br>在上面的通用类图中，<code>Client</code>类最终面对的是<code>Target</code>接口（或抽象类），它知识能够使用符合这一目标标准的子类；而<code>Adapter</code>类则是被适配的对象（也称源角色），因为它包含<code>specific</code>（特殊的）操作，功能等，所以我们想要在自己的系统中使用它，将其转换成符合我们标准的类，使得<code>Client</code>类可以在透明的情况下任意选择使用<code>Concrete Target</code>类或是具有特殊功能的<code>Adatee</code>类。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//已存在的，具有特殊功能的，但是不符合既有的标准接口的类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"被适配类具有特殊功能..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//目标接口，或称为标准接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体目标类，只提供普通功能</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span>  </span>&#123;</div><div class="line">        System.out.println(<span class="string">"普通类，具有普通功能..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//适配器类，继承了被适配类，同时实现了标准接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function">publc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//使用普通类功能</span></div><div class="line">        Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</div><div class="line">        concreteTarget.request();</div><div class="line">        <span class="comment">//使用特殊功能，即适配类</span></div><div class="line">        Target adapter = <span class="keyword">new</span> Adapter();</div><div class="line">        adapter.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种实现的适配器称为类适配器，因为<code>Adapter</code>类既继承了<code>Adaptee</code>（被适配类），也实现了<code>Target</code>接口（因为java不支持多继承，所以这样来实现），在<code>Client</code>类中我们可以根据需要选择并创建任意一种符合要求的子类，来实现具体功能。</p>
<p>另外一种适配器模式是对象适配器，它不是使用多继承或继承再实现的方式，而是使用直接关联，或者成为委托的方式，类图如下：<br><img src="/img/2017020903.jpg" alt="对象适配器模式类图"></p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//适配器类，直接关联被适配类，同时实现标准接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="comment">//直接关联被适配类</span></div><div class="line">    <span class="keyword">private</span> Adaptee adaptee;</div><div class="line"></div><div class="line">    <span class="comment">//可以通过构造函数传入具体需要适配的被适配对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee.specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//使用普通类</span></div><div class="line">        Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</div><div class="line">        concreteTarget.request();</div><div class="line">        <span class="comment">//使用特殊功能</span></div><div class="line">        Target adapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</div><div class="line">        adapter.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a>适配器模式的优缺点</h1><p><strong>优点</strong><br>适配器模式也是一种包装模式，对象适配器模式还有委托的意思。总的来说适配器模式属于补偿模式，专用来在系统后期扩展，修改时使用。</p>
<p><strong>缺点</strong><br>过多的使用适配器，会让系统非常凌乱，不易整体进行把握。比如，明明看到调用的是<code>A</code>接口，其实内部被适配称了<code>B</code>接口的实现，一个系统如果出现太多的这种情况，无异于异常灾难。因此如果不是很有必要，可以不适用适配器，而是直接对系统重构。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[原型模式]]></title>
      <url>http://iliubang.github.io/2017/02/09/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="原型模式概述"><a href="#原型模式概述" class="headerlink" title="原型模式概述"></a>原型模式概述</h1><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br>原型模式(prototype)是一种创建型设计模式，它允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节，工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们来实施创建。<br>原型模式主要解决的问题是：某些结构复杂的对象创建工作。由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。<br><a id="more"></a></p>
<p><img src="/img/2017020901.jpg" alt="原型模式类图"></p>
<p>原型模式主要用于对象的复制，他的核心就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：</p>
<ul>
<li>实现<code>Cloneable</code>接口。在java语言中有一个<code>Cloneable</code>接口，它的作用只有一个，就是在运行时通知虚拟机可以安全的在实现了此接口的类上使用<code>clone</code>方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出<code>CloneNotSupportedException</code>异常。</li>
<li>重写<code>Object</code>类中的<code>clone</code>方法。java中，所有类的基类都是<code>Object</code>类，其中有一个<code>clone</code>方法，作用是返回对象的一个拷贝，但是其作用域是protected类型，一般的类无法调用，因此，<code>Prototype</code>类需要将<code>clone</code>改为public类型。</li>
</ul>
<h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Prototype prototype = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            prototype = (Prototype)<span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"运行模式实现"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</div><div class="line">        ConcretePrototype cp = <span class="keyword">new</span> ConcretePrototype();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&gt;) &#123;</div><div class="line">            ConcretePrototype clonecp = (ConcretePrototype)cp.clone();</div><div class="line">            clonecp.show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="原型模式的优点和应用场景"><a href="#原型模式的优点和应用场景" class="headerlink" title="原型模式的优点和应用场景"></a>原型模式的优点和应用场景</h1><p>使用原型模式创建对象比直接new一个对象在性能上好的多，因为<code>Object</code>类的<code>clone</code>方法是一个native方法，它直接操作内存中的二进制流，特别是复制大对象时，性能差别非常明显。<br>使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档的复制粘贴一样简单。<br>因为以上优点，所以在需要重复创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式可以简化创建过程，而且提高性能。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>使用原型模式创建对象不会调用类的构造方法。因为对象的复制是直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。也即是说，即使构造方法为private，也可以使用<code>clone</code>来创建对象。</li>
<li>深拷贝和浅拷贝。<code>Object</code>类中的<code>clone</code>方法只会拷贝对象中的基本数据类型，对于数组，容器对象，引用对象都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型中的数组，容器对象，引用对象等另行拷贝。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList list = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Prototype prototype = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            prototype = (Prototype)<span class="keyword">super</span>.clone();</div><div class="line">            prototype.list = (ArrayList)<span class="keyword">this</span>.list.cone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[建造者模式]]></title>
      <url>http://iliubang.github.io/2017/02/08/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="建造者模式概述"><a href="#建造者模式概述" class="headerlink" title="建造者模式概述"></a>建造者模式概述</h1><p>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。<br><a id="more"></a></p>
<h1 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h1><ol>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时。</li>
<li>当构造过程必须允许被构造的对象有不同表示时。</li>
</ol>
<p><img src="/img/2017020801.jpg" alt="建造者模式类图"></p>
<h1 id="四个要素"><a href="#四个要素" class="headerlink" title="四个要素"></a>四个要素</h1><ul>
<li>产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类途中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与他的不同实现组成，也可以是由多个抽象类与他们的实现组成。</li>
<li>抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交给它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个用来返回产品。</li>
<li>建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。</li>
<li>导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演被用来封装程序中易变的部分。</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> String type;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"名称："</span> + name);</div><div class="line">        System.out.println(<span class="string">"型号："</span> + type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPar</span><span class="params">(String arg1, String arg2)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        product.setName(arg1);</div><div class="line">        product.setType(arg2);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">new</span> ConcreteBuilder();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getAProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        builder.setPart(<span class="string">"宝马"</span>, <span class="string">"X7"</span>);</div><div class="line">        <span class="keyword">return</span> builder.getProduct();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getBProduct</span><span class="params">()</span> </span>&#123;</div><div class="line">        builder.setPart(<span class="string">"奥迪"</span>, <span class="string">"Q7"</span>);</div><div class="line">        <span class="keyword">return</span> builder.getProduct();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Director director = <span class="keyword">new</span> Director();</div><div class="line">        Product product1 = director.getAProduct();</div><div class="line">        product1.showProduct();</div><div class="line">        Product product2 = director.getBProduct();</div><div class="line">        product2.showProduct();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h1><p>首先，建造者模式的封装性很好，使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。<br>其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。</p>
<h1 id="建造者模式与工厂模式的区别"><a href="#建造者模式与工厂模式的区别" class="headerlink" title="建造者模式与工厂模式的区别"></a>建造者模式与工厂模式的区别</h1><p>我们可以看到，建造者模式与工厂模式极为相似，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，加入把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看做是一个简单的工厂模式了。<br>与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类–导演类。也就是说，工厂模式是将对象的全部创建过程封装在了工厂中了，有工厂类想客户端提供终端产品；而建造者模式中，建造者类一般只提供产品中各个组件的装配，而将具体建造过程交给导演。由导演负责将各个组件按照特定的规则组件成产品，然后交付给客户端。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单例模式]]></title>
      <url>http://iliubang.github.io/2017/02/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="单例模式概述"><a href="#单例模式概述" class="headerlink" title="单例模式概述"></a>单例模式概述</h1><p>单例模式是一种常用的软件设计模式。在他的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。<br>数学和逻辑学中，singleton定义为“有且仅有一个元素的集合”.<br>单例模式最初的定义出现在《设计模式》（艾迪生维斯理，1994）：“保证一个类仅有一个实例，并提供一个访问它的全局访问点。”<br><a id="more"></a></p>
<h1 id="基本实现思路"><a href="#基本实现思路" class="headerlink" title="基本实现思路"></a>基本实现思路</h1><p>单例模式要求能够有返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）<br>单例的实现主要是通过以下两个步骤：</p>
<ol>
<li>将该类的构造方法私有化，这样其他处理的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类唯一的实例；</li>
<li>在该类内部提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果为空就创建该类的实例并将其赋值给该类持有的引用。</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>单例模式在多线程的应用场合下必须小心使用，如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么他们同时没有检测到唯一实例的存在，从而各自创建一个实例，这样就有两个实例被创建出来，从而违反了单例模式中实例唯一的原则。解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁（虽然这样会降低效率）</p>
<h1 id="单例模式的8种写法"><a href="#单例模式的8种写法" class="headerlink" title="单例模式的8种写法"></a>单例模式的8种写法</h1><h2 id="饿汉式（静态常亮）"><a href="#饿汉式（静态常亮）" class="headerlink" title="饿汉式（静态常亮）"></a>饿汉式（静态常亮）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步的问题。<br>缺点：在类装载完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<h2 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式和上面的方式其实类似，只不过将实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面一样。</p>
<h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了<code>if(singleton == null)</code>判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时就会产生多个实例。所以在多线程下不可使用这种方式。</p>
<h2 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决上面第三种实现方式线程不安全问题，做个线程同步就可以了，于是就对<code>getInstance</code>方法进行了线程同步。<br>缺点：效率太低了，每个线程想获得类的实例的时候，执行<code>getInstance</code>方法都要进行同步。而其实这个方法只执行一次实例代码就够了，后面想获得实例，就直接<code>return</code>就行了。方法进行同步效率太低要改进。</p>
<h2 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</div><div class="line">                singleton = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的代码块。但是这种同步的方式不能起到线程同步的作用。跟第三种实现方式遇到的清醒一致，假如一个线程进入了判断语句，还没有来得及往下执行另一个线程也通过了判断，这时候就会产生多个实例。</p>
<h2 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">                    singleton = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次<code>if (singleton == null)</code>的判断，这样就可以保证线程安全了。这样实例化代码只用执行一次，后面再次访问时候直接<code>return</code>掉。<br>优点：线程安全；延迟加载；效率较高。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法跟饿汉式采用的机制类似，但又不同。两者都是采用了类装载机制来保证初始化实例的时候只有一个线程。不同的是饿汉式是在类装载的时候实例化，而静态内部类的方式在Singleton类被装载的时候不会立即实例化，而是在调用getInstance方法时才会装载SingletonInstance类，从而完成单例。<br>优点：线程安全，延迟加载，效率高。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然单例模式有这么多写法，但是其核心思想是不变的，即保证一个类有且仅有一个实例对象，在实际的开发中，我们应该结合场景选择合适的一种。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[工厂设计模式]]></title>
      <url>http://iliubang.github.io/2017/02/07/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="工厂模式概述"><a href="#工厂模式概述" class="headerlink" title="工厂模式概述"></a>工厂模式概述</h1><p>工厂(Factory Pattern)模式是Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p><img src="/img/2017020701.jpg" alt="uml图"></p>
<a id="more"></a>
<p>下面来看一个小小的栗子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operate)</span> </span>&#123;</div><div class="line">    Operation op = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">switch</span>(operate) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"+"</span>:</div><div class="line">            op = <span class="keyword">new</span> OperationAdd();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"-"</span>:</div><div class="line">            op = <span class="keyword">new</span> OperationSub();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"*"</span>:</div><div class="line">            op = <span class="keyword">new</span> OperationMul();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"/"</span>:</div><div class="line">            op = <span class="keyword">new</span> OperationDiv();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> op;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优点：客户端不需要修改代码<br>缺点：当需要增加新的运算类的时候，不仅需新加运算类，还要修改工厂类，违反了开闭原则。</p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。<br><img src="/img/2017020702.jpg" alt="uml图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Shape.java</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Rectangle.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Rectangle::draw() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Square.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Square::draw() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Circle.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Circle::draw() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Color.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Red.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Red::fill() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Green.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Green::fill() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Blue.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside Blue::fill() method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//为Color和Shape对象创建抽象类来获取工厂</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> class <span class="title">AbstractFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建扩展了AbstractFactory的工厂类，基于给定的信息生成实体类的对象。</span></div><div class="line"><span class="comment">//ShapeFactory</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (shape == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (shape.equalsIgnoreCase(<span class="string">"circle"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equalsIgnoreCase(<span class="string">"square"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equalsIgnoreCase(<span class="string">"rectangle"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ColorFactory</span></div><div class="line">publicc <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbastractFactory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (color == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"red"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Red();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"green"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Green();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"blue"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> blue();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>http://iliubang.github.io/2017/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式(design patterns)是一套被反复使用、多数人知晓的、经过分类编目的代码设计经验总结。使用设计模式是为了可重用代码、让代码更容易被他人理解，保证代码的可靠性。毫无疑问，设计模式于己于人都是有利的。设计模式使代码编制真正工程化，设计模式是软件工程的基石，如通大厦的一块砖石一样。项目中合理运用设计模式可以完美的解决很多问题，每种设计模式在现在中都有相应的原理与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p>
<a id="more"></a>
<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五中：</p>
<ul>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>单例模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ul>
<p>结构型模式，共七种：</p>
<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<p>行为型模式，共十一种类：</p>
<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代子模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
<p>其实还有两类：并发型模式和线程池模式</p>
<h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><p><strong>1. 开闭原则(Open Close Principle)</strong><br>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行扩展的时候，不能修改原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p>
<p><strong>2. 里氏替换原则(Liskov Substitution Principle)</strong><br>里氏替换原则(Liskov Substitution Principle LSP)是面向对象设计的基本原则之一。里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏替换原则是对“开闭原则”的补充。实现“开闭原则”的关键步骤是抽象化。而基类与衍生类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3. 依赖倒转原则(Dependence Inversion Principle)</strong><br>这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4. 接口隔离原则(Interface Segregation Principle)</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间耦合度的意思。从这里我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。</p>
<p><strong>5. 迪米特法则(最少了解原则)(Demeter Principle)</strong><br>定义：一个对象应该对其他对象保持最少的了解，从而使得功能模块相对独立。</p>
<p><strong>6. 合成复用原则(Composite Reuse Principle)</strong><br>尽量使用合成/聚合的方式，而不使用继承。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于C语言的编程语言开发yacc_lex初步]]></title>
      <url>http://iliubang.github.io/2017/02/06/%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91yacc-lex%E5%88%9D%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>当今世道，各种高级语言百花齐放。然而会有人发出这样的疑问–计算机真的能够识别这么多语言吗？稍微有点常识的人都知道，这显然是不可能滴！在计算机的世界里，他们能够直接识别的只有机器语言。然而，由于机器语言对人类不够友好，所以人们才发明了汇编，c，Java…许许多多的人类易读的编程语言，所以我个人对编程语言的理解一直是其实他们就是机器语言的语法糖，而编程语言的创造过程，就是定义一种合理的，没有二义性的语法规则，然后就是通过直接或间接的方式实现该语法到机器语言的转换过程。既然是这样的话，那么我们就很容易想到，计算机语言是一个自我完善的过程：首先我们定了一种非常简单的x1(这里只是用来举例说明，有没有x语言有待考证)语言，然后用机器语言实现了这个非常简单的x1语言的编译器，创造了x1语言，实现了非常简单的新特性，然后我们再用x1语言(相对于机器语言较高级)实现了另一些新的特性的x2语言的编译器，创造了x2语言，…<a id="more"></a>，如此下去，人们创造了汇编语言，从而创造了c语言，接着创造了世界上最好的语言PHP(不知道是不是真的，反正大家都习惯这么说)。<br>在各种高级语言越来越强大的今天，我们可能很难再会去接触最原始的东西，高度封装确实提高了生产力，降低了学习成本，但是也使得现代程序员将太多精力花在了各种说明书上，而不清楚其本质。<br>毕业一年多，工作了一年多，对于计算机编程有了自己的看法，不再像在大学的时候认识的那样肤浅，反而觉得大学中学习的知识才是真正的干货，不禁感叹曾经浪费掉了大好光阴。好在陶渊明有词云：“悟已往之不谏，知来者之可追”。<br>闲暇之余，扒开PHP(这里之所以是PHP并不因为他是世界上最好的语言，只是因为我目前从事的是PHP开发的工作而已)源码，了解了其内部构造和实现原理，百看不一练。今天就初步学习yacc/lex了，记录在我的博客中，以便以后翻阅巩固。</p>
<h1 id="过程简述"><a href="#过程简述" class="headerlink" title="过程简述"></a>过程简述</h1><p>一般来说编程语言的解释执行过程如下：</p>
<p><strong>ONE</strong>. 词法分析<br>将源代码拆分成若干Token的过程</p>
<p><strong>TWO</strong>.语法分析<br>将Token构建成Syntax Tree的过程</p>
<p><strong>THREE</strong>.生成执行码<br>生成可执行文件</p>
<h1 id="yacc（Yet-Another-Compiler-Compiler）"><a href="#yacc（Yet-Another-Compiler-Compiler）" class="headerlink" title="yacc（Yet Another Compiler Compiler）"></a>yacc（Yet Another Compiler Compiler）</h1><p>下面是wikipedia中对yacc的描述</p>
<blockquote>
<p>Yacc is a computer program for the Unix operating system. It is a Look Ahead Left-to-Right (LALR) parser generator, generating a parser, the part of a compiler that tries to make syntactic sense of the source code, specifically a LALR parser, based on an analytic grammar written in a notation similar to Backus–Naur Form (BNF). Yacc itself used to be available as the default parser generator on most Unix systems, though it has since been supplanted as the default by more recent, largely compatible, programs.</p>
</blockquote>
<p>其安装非常简单</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install bison</div></pre></td></tr></table></figure>
<h1 id="lex-flex"><a href="#lex-flex" class="headerlink" title="lex/flex"></a>lex/flex</h1><p>lex 是一个生成词法分析器的工具。Lex读进一个代表词法分析器规则的输入字符串流，然后输出以C语言实做的词法分析器源代码。传统上，lex属于商业软件，但是有些根据原本AT&amp;T代码这些版本的Lex可以以公开源代码的形式获得，并被视为某些系统的一部分，例如说OpenSolaris和贝尔实验室九号项目。另一个有名的Lex公开源代码版本是flex，代表”快速的词法分析器”（fast lexical analyzer）</p>
<p>在linux下安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install flex</div></pre></td></tr></table></figure>
<h1 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h1><ul>
<li>实现一个简单的计算程序</li>
</ul>
<p>首先定义lex规则，其扩展名为<code>.l</code>，在lex中可以很容易读懂其定义的规则，因为他用到的是正则表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">%&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"y.tab.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">yywrap</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">%&#125;</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line"><span class="string">"+"</span>		<span class="keyword">return</span> ADD;</div><div class="line"><span class="string">"-"</span>		<span class="keyword">return</span> SUB;</div><div class="line"><span class="string">"*"</span>		<span class="keyword">return</span> MUL;</div><div class="line"><span class="string">"/"</span>		<span class="keyword">return</span> DIV;</div><div class="line"><span class="string">"\n"</span>		<span class="keyword">return</span> CR;</div><div class="line"></div><div class="line">([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*)|<span class="number">0</span>|([<span class="number">0</span><span class="number">-9</span>]+\.[<span class="number">0</span><span class="number">-9</span>]+) &#123;</div><div class="line">	<span class="keyword">double</span> d;</div><div class="line">	<span class="built_in">sscanf</span>(yytext, <span class="string">"%lf"</span>, &amp;d);</div><div class="line">	yylval.double_value = d;</div><div class="line">	<span class="keyword">return</span> DOUBLE_LITERAL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">[ \t] ;</div><div class="line">. &#123;</div><div class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"lexical error.\n"</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">%%</div></pre></td></tr></table></figure>
<p>可以看到以上的代码主要包含两部分，<code>%{</code> <code>%}</code>包含的部分和<code>%%</code> <code>%%</code>包含的部分。前一部分叫<strong>定义区块</strong>, 后者是<strong>规则区块</strong>，定义区块内的代码将会被原样输出，在定义区块中<code>#include &quot;y.tab.h&quot;</code>将会在yacc编译其规则文件后自动生成，<code>ADD</code> <code>SUB</code> <code>MUL</code> <code>DIV</code> <code>CR</code> <code>DOUBLE_LITERAL</code>等都是在y.tab.h中定义的macro。<br>在定义区块中，有一个名为<code>yywrap</code>的function，其作用是自动link lex的库文件。<br>至于规则区块，学过正则表达式的人一看就会明白，其作用就是使用正则表达式来描述Token。规则区块的定义为：正则表达式，后边跟上C代码，这些代码用<code>{}</code>括起来，读入的字符流满足了正则，则执行其后的代码，匹配到的原字符被保存在<code>yytext</code>这个全局变量中。</p>
<p>接着来编写yacc的规则，其扩展名为<code>.y</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">%&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> YYDEBUG 1</span></div><div class="line"></div><div class="line">%&#125;</div><div class="line"></div><div class="line">%<span class="keyword">union</span> &#123;</div><div class="line">	<span class="keyword">int</span>	int_value;</div><div class="line">	<span class="keyword">double</span>	double_value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">%token &lt;double_value&gt;		DOUBLE_LITERAL</div><div class="line">%token ADD SUB MUL DIV CR</div><div class="line">%type &lt;double_value&gt; expression term primary_expression</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">line_list</div><div class="line">	: line</div><div class="line">	| line_list line</div><div class="line">;</div><div class="line">line</div><div class="line">	: expression CR</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"&gt;&gt;%lf\n"</span>, $<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">expression</div><div class="line">	: term</div><div class="line">	| expression ADD term</div><div class="line">	&#123;</div><div class="line">		$$ = $<span class="number">1</span> + $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">	| expression SUB term</div><div class="line">	&#123;</div><div class="line">		$$ = $<span class="number">1</span> - $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">term</div><div class="line">	: primary_expression</div><div class="line">	| term MUL primary_expression</div><div class="line">	&#123;</div><div class="line">		$$ = $<span class="number">1</span> * $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">	| term DIV primary_expression</div><div class="line">	&#123;</div><div class="line">		$$ = $<span class="number">1</span> / $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">primary_expression</div><div class="line">	: DOUBLE_LITERAL</div><div class="line">;</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">yyerror</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">extern</span> <span class="keyword">char</span> *yytext;</div><div class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"syntax error near %s\n"</span>, yytext);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">yyparse</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">	<span class="keyword">extern</span> FILE *yyin;</div><div class="line"></div><div class="line">	yyin = <span class="built_in">stdin</span>;</div><div class="line">	<span class="keyword">if</span> (yyparse()) &#123;</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Core Dump!\n"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>yacc规则定义跟lex相似，都用到了<code>\%{\%}</code> <code>%%</code>来包含代码块。<br>同样的是<code>\%{\%}</code>包裹的代码将被原样输出。<br>在<code>%union</code>定义中，声明了记号和非终结符的类型，其最终会被编译成一个c语言的union。这里定义了一个int 类型的<code>int_value</code> 和 double类型的<code>double_value</code>。<br><code>%token</code>开头的行是Token的声明，所有用到的Token类型都在这里定义。对于<code>ADD</code> <code>SUB</code> <code>MUL</code> <code>DIV</code> <code>CR</code>等记号只需要包含其类型即可，而对于值为<code>DOUBLE_LITERAL</code>的Token，其类型被指定为<code>&lt;double_value&gt;</code>，这里的double_value正是来自于前面声明的union中的成员之一。<br><code>%%</code>包裹的部分叫做规则区块，由语法规则和C语言编写的相应的行为两部分构成。在yacc中使用了类似于BNF范式来编写语法规则。由于使用了自然语言作为标记，理解上还是很容易的。下面举个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">line_list                 <span class="comment">/* 多行规则 */</span></div><div class="line">	: line                  <span class="comment">/* 单行 */</span></div><div class="line">	| line_list line        <span class="comment">/* 或者多行后跟单行 */</span></div><div class="line">;</div><div class="line">line                       <span class="comment">/* 单行 */</span></div><div class="line">	: expression CR          <span class="comment">/* 表达式后跟换行符 */</span></div><div class="line">;</div><div class="line">expression                 <span class="comment">/* 表达式 */</span></div><div class="line">	: term                   <span class="comment">/* 和项 */</span></div><div class="line">	| expression ADD term    <span class="comment">/* 或者表达式加上和项 */</span></div><div class="line">	&#123;                        <span class="comment">/* 匹配后执行的action */</span></div><div class="line">		$$ = $<span class="number">1</span> + $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">	| expression SUB term    <span class="comment">/* 或者表达式减去和项 */</span></div><div class="line">	&#123;                        <span class="comment">/* 匹配后执行的action */</span></div><div class="line">		$$ = $<span class="number">1</span> - $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">term                        <span class="comment">/* 和项 */</span></div><div class="line">	: primary_expression      <span class="comment">/* 一元表达式 */</span></div><div class="line">	| term MUL primary_expression <span class="comment">/* 或者和项乘以一元表达式 */</span></div><div class="line">	&#123;                          <span class="comment">/* 匹配后执行的action */</span></div><div class="line">		$$ = $<span class="number">1</span> * $<span class="number">3</span>;</div><div class="line">	&#125;                          </div><div class="line">	| term DIV primary_expression <span class="comment">/* 或者和项除以一元表达式 */</span></div><div class="line">	&#123;                             <span class="comment">/* 匹配后执行的action */</span></div><div class="line">		$$ = $<span class="number">1</span> / $<span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">;</div><div class="line">primary_expression          <span class="comment">/* 一元表达式 */</span></div><div class="line">	: DOUBLE_LITERAL          <span class="comment">/* 实数字面量 */</span></div><div class="line">;</div></pre></td></tr></table></figure>
<p>写好了规则，那么就来编译运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yacc -dv foo.y</div><div class="line">flex foo.l</div><div class="line">gcc -std=c99 -Wall -g -o foo y.tab.c lex.yy.c</div></pre></td></tr></table></figure>
<p>这样就生成了<code>foo</code>这个可执行文件<br>运行foo</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">liubang@venux:~/workspace/c/my_lang/lex$ make run</div><div class="line">1 + 3</div><div class="line">&gt;&gt;4.000000</div><div class="line">1/2 </div><div class="line">&gt;&gt;0.500000</div><div class="line">4 * 5</div><div class="line">&gt;&gt;20.000000</div></pre></td></tr></table></figure>
<p>当然我个人在开发c程序的时候偏向于使用make工具来编译代码，这样会很方便。下面是我的Makefile文件:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">CFLAGS = -O2 -g -Wall -std=c99</div><div class="line">EXEC = foo</div><div class="line">OBJS =	y.tab.o \</div><div class="line">	lex.yy.o</div><div class="line"></div><div class="line"></div><div class="line">%.c:</div><div class="line">	yacc -dv foo.y</div><div class="line">	lex foo.l</div><div class="line"></div><div class="line">%.o: %.c</div><div class="line">	 <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o $@ -c $&lt;</div><div class="line"></div><div class="line">$(EXEC): $(OBJS)</div><div class="line">	<span class="variable">$(CC)</span> <span class="variable">$(OBJS)</span> -o $@</div><div class="line"></div><div class="line">all: $(EXEC)</div><div class="line"></div><div class="line">run: $(EXEC)</div><div class="line">	@./<span class="variable">$(EXEC)</span></div><div class="line"></div><div class="line"><span class="section">clean:</span></div><div class="line">	<span class="variable">$(RM)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(EXEC)</span></div></pre></td></tr></table></figure>
<p>只需要执行<code>make run</code>命令即可运行！</p>
<h1 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h1><p>可能有人会疑惑，这玩意学着有什么用，那么有兴趣的你可以下载一份PHP的源代码，在Zend(Zend引擎核心文件)目录中你不难找到<code>zend_language_scanner.l</code>,<code>zend_ini_scanner.l</code>,<code>zend_ini_parser.y</code>,<code>zend_language_parser.y</code>这几个文件，打开其内容，是不是不再那么恐惧和陌生了呢。</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>本文只是初步介绍yacc/lex工具生成词法解析器和语法解析器的最基本用法，没有太多的阐述词法解析的原理和过程，所以更偏实践，再由于本人毕业一年多实在很久没写文章了，常常会提笔不知从何说起，所以写起来很慢，加之白天要工作，时间较紧，所以今天就到这里了，至于理论的阐述，需要时间来慢慢酝酿😂！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Demo]]></title>
      <url>http://iliubang.github.io/2017/02/06/Demo/</url>
      <content type="html"><![CDATA[<p>this is my demo document.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="title">foo</span></div><div class="line"></div><div class="line"><span class="title">class</span> <span class="title">App</span> &#123;</div><div class="line">    </div><div class="line">    <span class="title">private</span> <span class="title">static</span> $<span class="title">instance</span> = <span class="title">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;    </div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>::$instance <span class="keyword">instanceof</span> <span class="keyword">self</span>) &#123;</div><div class="line">            <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="test-math"><a href="#test-math" class="headerlink" title="test math"></a>test math</h2><p>这是测试用的$\lambda$</p>
<p>$$\frac{\partial u}{\partial t}<br>= h^2 \left( \frac{\partial^2 u}{\partial x^2} +<br>\frac{\partial^2 u}{\partial y^2} +<br>\frac{\partial^2 u}{\partial z^2}\right)$$</p>
<p>$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$</p>
]]></content>
    </entry>
    
  
  
</search>
