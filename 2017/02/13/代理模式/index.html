<!DOCTYPE html>
<html lang="">
  <head>
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="代理模式"/>




  <meta name="keywords" content="design patterns,proxy," />




  <link rel="alternate" href="/atom.xml" title="BangLau">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.2.x" />



<link rel="canonical" href="http://iliubang.github.io/2017/02/13/代理模式/"/>


<meta name="description" content="代理模式概述为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
代理模式的优点1. 职责清晰真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。
2. 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保">
<meta property="og:type" content="article">
<meta property="og:title" content="代理模式">
<meta property="og:url" content="http://iliubang.github.io/2017/02/13/代理模式/index.html">
<meta property="og:site_name" content="BangLau">
<meta property="og:description" content="代理模式概述为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
代理模式的优点1. 职责清晰真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。
2. 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保">
<meta property="og:image" content="http://iliubang.github.io/img/01161112_84ux.gif">
<meta property="og:image" content="http://iliubang.github.io/img/01161112_WnAK.gif">
<meta property="og:image" content="http://iliubang.github.io/img/clip_image006_2.gif">
<meta property="og:image" content="http://iliubang.github.io/img/01161112_rdxV.gif">
<meta property="og:image" content="http://iliubang.github.io/img/clip_image010_2.gif">
<meta property="og:image" content="http://iliubang.github.io/img/01161112_LwaC.gif">
<meta property="og:image" content="http://iliubang.github.io/img/clip_image014_2.gif">
<meta property="og:image" content="http://iliubang.github.io/img/01161112_Fpoh.gif">
<meta property="og:image" content="http://iliubang.github.io/img/01161112_v1d4.jpg">
<meta property="og:updated_time" content="2017-02-15T04:30:24.197Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代理模式">
<meta name="twitter:description" content="代理模式概述为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
代理模式的优点1. 职责清晰真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。
2. 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保">
<meta name="twitter:image" content="http://iliubang.github.io/img/01161112_84ux.gif">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.2.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script type="text/javascript">
  var themeConfig = {
    search: {
      enable: true,
      path: "/search.xml",
    },
    navbar: {
      enable: true
    },
    fancybox: {
      enable: true
    },
    toc: {
      enable: true
    },
  };
</script>



  



    <title> 代理模式 · BangLau </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">BangLau</a>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
      
        <li class="menu-search">
          <form>
            <i class="iconfont icon-search" id="open-search"></i>
            <input type="text" class="search-input" id="search-input" />
            <i class="iconfont icon-close" id="close-search"></i>
          </form>
        </li>
      
    </ul>
  
</nav>

<div class="mobile-navbar">
  <div class="mobile-header">
    <div class="mobile-header-logo">
      <a href="/." class="logo">BangLau</a>
    </div>

    <div class="mobile-header-icon">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  <nav class="mobile-menu">
    
      <a class="mobile-menu-item" href="/">
        
        
          Home
        
      </a>
    
      <a class="mobile-menu-item" href="/archives/">
        
        
          Archives
        
      </a>
    
      <a class="mobile-menu-item" href="/categories">
        
        
          Categories
        
      </a>
    
      <a class="mobile-menu-item" href="/tags">
        
        
          Tags
        
      </a>
    
      <a class="mobile-menu-item" href="/about">
        
        
          About
        
      </a>
    
  </nav>
</div>
      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          代理模式
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Feb 13, 2017
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#代理模式概述"><span class="toc-text">代理模式概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代理模式的优点"><span class="toc-text">代理模式的优点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代理模式-Proxy-概述"><span class="toc-text">代理模式(Proxy)概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代理模式的定义"><span class="toc-text">代理模式的定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代理模式的应用"><span class="toc-text">代理模式的应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代理模式的扩展"><span class="toc-text">代理模式的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#普通代理"><span class="toc-text">普通代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#强制代理"><span class="toc-text">强制代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理是有个性的"><span class="toc-text">代理是有个性的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟代理"><span class="toc-text">虚拟代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代理"><span class="toc-text">动态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最佳实践"><span class="toc-text">最佳实践</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <h1 id="代理模式概述"><a href="#代理模式概述" class="headerlink" title="代理模式概述"></a>代理模式概述</h1><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<h1 id="代理模式的优点"><a href="#代理模式的优点" class="headerlink" title="代理模式的优点"></a>代理模式的优点</h1><p><strong>1. 职责清晰</strong><br>真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。</p>
<p><strong>2. 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用</strong></p>
<p><strong>3. 高扩展性</strong></p>
<a id="more"></a>
<h1 id="代理模式-Proxy-概述"><a href="#代理模式-Proxy-概述" class="headerlink" title="代理模式(Proxy)概述"></a>代理模式(Proxy)概述</h1><p>代理模式是23种常用的OOP软件开发的设计模式之一。代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不合适或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。</p>
<p>以下内容转载于<a href="https://my.oschina.net/wizardmerlin/blog/513078" target="_blank" rel="external">https://my.oschina.net/wizardmerlin/blog/513078</a></p>
<hr>
<p>2007年，感觉很无聊，于是就玩了一段时间的网络游戏，游戏名就不说了，要不就有做广告的嫌疑，反正就是打怪、升级、砍人、被人砍，然后继续打怪、升级、打怪、升级。。。我花了两个月的时间升级到了80级，已经很有成就感了，但是还被人杀死，高手到处都是，GM(Game Master,游戏管理员)也不管，对于咱这种非RMB玩家基本上都是懒得搭理。在这段时间我是体会到了网络游戏的苦与乐，参与家族（工会）攻城，胜利后那叫一个乐呀，感觉自己真是一个“狂暴战士”，无往不胜！那苦是什么呢？就是升级，为了升一级，就要到处杀怪，做任务，那个游戏还很变态，外挂管的很严，基本上出个外挂，没了两天就开始封号，不敢用，升级基本上都要靠自己手打，累呀！我曾经的记录是连着打了23个小时，睡觉在梦中还和大BOSS在PK。有这样一段经历还是很有意思的，作为架构师是不是可以把这段经历通过架构的方式记录下来呢？当然可以了，我们把这段打游戏的过程系统化，非常简单的一个过程，如图所示：</p>
<p><img src="/img/01161112_84ux.gif" alt="游戏过程"></p>
<p>太简单了，定义一个接口<code>IGamePlayer</code>，是所有喜欢网络游戏的玩家，然后定义一个具体的实现类<code>IGamePlayer</code>，实现每个游戏爱好者为了玩游戏要执行的功能。代码也非常简单，我们先来看<code>IGamePlayer</code>，代码清单如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//游戏者接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="comment">//登录游戏</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//杀怪，网络游戏的主要特色</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//升级</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简单，定义了三个方法，分别是我们在网络游戏中最常用的功能：登录游戏，杀怪和升级，其实实现类如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//游戏者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name = <span class="string">""</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//通过构造函数传递名称</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(String _name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = _name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//打怪，最期望的就是杀老怪</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"在打怪"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//进游戏之前你肯定要登录吧，这是一个必要条件</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"登录名为"</span> + user + <span class="string">"用户名"</span> + <span class="keyword">this</span>.name + <span class="string">"登录成功！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//升级，升级有很多方法，花钱买一种，做任务也是一种</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"　又升了一级！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实现类中通过构造函数传递进来玩家的姓名，方便进行后期的调试工作。</p>
<p><em>客户端调用简单再次略过</em></p>
<p>心理学家告诉我们，人类对于苦难的记忆比对喜悦的记忆要深刻，但是人类对于喜悦是“趋利”性的，每个人都想Happy，都不想让苦难靠近，要想获得幸福，苦难也是再所难免的，我们的网游生涯也是如此，游戏打的时间长了，腰酸背痛，眼睛干涩，手臂酸麻，等等，也就是网络成瘾综合征都出来了，其结果就是类似吃了那个“一日丧命散”，“筋脉逆流，胡思乱想，而导致走火入魔”。那怎么办呢？我们想玩游戏，但又不想触碰到游戏中的烦恼？如何解决呢？<br>有办法，现在游戏代练的公司非常多，我把自己的账号交给代练员，由他们去帮我们升级，去打怪，非常好的想法，我们来修改一下类图，如下所示：</p>
<p><img src="/img/01161112_WnAK.gif" alt=""></p>
<p>在类图中增加了一个<code>GamePlayerProxy</code>类来代表游戏代练者，它也不能有作弊的方法呀，游戏代练者也是手动打怪呀，因此同样继承<code>IGamePlayer</code>接口，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//通过构造函数传递要对谁进行代练</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(IGamePlayer _gamePlayer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer = _gamePlayer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//代练杀怪</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.killBoss();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//代练登录</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.login(user, password);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//代练升级</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.upgrade();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，首先通过构造函数说明要代谁打怪升级，然后通过手动开始代用户打怪、升级。场景类Client代码也稍作改动，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>);</div><div class="line"></div><div class="line">        IGamePlayer proxy = <span class="keyword">new</span> GamePlayerProxy(player);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"开始时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line"></div><div class="line">        proxy.login(<span class="string">"zhangsan"</span>, <span class="string">"password"</span>)</div><div class="line"></div><div class="line">        proxy.killBoss();</div><div class="line"></div><div class="line">        proxy.upgrade();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"结束时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果也完全相同，还是张三这个用户在打怪</p>
<p>是的，没有任何改变，但是你有没有发觉，你的游戏已经在升级，有人在帮你干活了！终于升级到120级，然后基本上是本服无敌手，除了GM外，这个你可惹不起！这就是代理模式。</p>
<h1 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h1><p>代理模式(Proxy Pattern)是一个使用率非常高的模式，其定义如下：<br>provide a surrogate or placeholder for another object to control access to it. 为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>下图是代理模式的通用类图</p>
<p><img src="/img/clip_image006_2.gif" alt="代理模式通用类图"></p>
<p>代理模式也叫委托模式，他是一项基本的设计技巧，许多其他的模式，如状态模式，策略模式，访问者模式本质上是在更特殊的场合采用了委托模式，而且在日常的应用中，代理模式可以提供非常好的访问控制，在一些著名开源软件中也经常见到它的影子，如Strus2的Form元素的映射就采用了代理模式（准确说是动态代理模式）。我们先看一下类途中定义的三个角色：</p>
<p><code>Subject</code>抽象主题角色：抽象主题角色可以是抽象类也可以是接口，是一个最普遍的业务类型定义，无特殊要求。</p>
<p><code>RealSubject</code>具体主题角色：也叫作被委托角色，被代理角色，它才是冤大头，是业务逻辑的具体执行者。</p>
<p><code>Proxy</code>代理主题角色：也叫作委托类，代理类，它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完前后做预处理和善后处理的工作。</p>
<p>我们首先来看<code>Subject</code>抽象主题类的通用源码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">//定义一个方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在接口中我们定义了一个方法<code>request</code>来作为方法的代表，<code>RealSubject</code>对它进行实现，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">//实现方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//业务逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>RealSubject</code>是一个正常的业务实现类，代理模式的核心就是在代理类上，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">//要代理哪个实现类</span></div><div class="line">    <span class="keyword">private</span> Subject subject = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//默认被代理者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subject = <span class="keyword">new</span> Proxy();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//通过构造函数传递代理者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Object...objects)</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.before();</div><div class="line">        <span class="keyword">this</span>.subject.request();</div><div class="line">        <span class="keyword">this</span>.after();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//预处理</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//善后处理</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，大家别惊讶，为什么会出现<code>before</code>和<code>after</code>方法，继续看下去，这是一个“引子”，能够引出一个崭新的编程模式。<br>一个代理类可以代理多个被委托者或代理者，因此一个代理类具体代理那个真实主题角色，是由场景决定的，当然，最简单的情况就是一个主题类一个代理类，这是最简洁的代理模式。在通常情况下，一个接口只需要一个代理类就可以了，具体代理哪个实现类由高层模块来决定，也就是在代理类的构造函数中传递被代理者，例如我们可以在代理类<code>Proxy</code>中增加代码如下的构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject _subject)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.subject = _subject;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你要代理谁，产生该代理的实例，然后把被代理者传递进来，该模式在实际的项目应用中比较广泛。</p>
<h1 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h1><p>我相信第一次接触到代理模式的读者肯定很郁闷，为什么要用代理呀，是的，为什么要用代理？想想现实世界吧，你为什么要找代理律师，你去打官司，为什么要找到个律师？因为你不想参与中间过程的是是非非，只要完成自己的答辩就行，其他的比如事前调查，事后追查都由律师来搞定，这就是为了减轻你的负担。代理模式使用非常多，大家可以看看Spring AOP，这是一个非常典型的动态代理。</p>
<h1 id="代理模式的扩展"><a href="#代理模式的扩展" class="headerlink" title="代理模式的扩展"></a>代理模式的扩展</h1><h2 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h2><p>在网络上代理服务器设置分为透明代理和普通代理，什么意思呢？透明代理就是用户不能设置代理服务器地址，就可以直接访问，也就是说代理服务器对用户来说透明的，看不到，不用知道它的存在；普通代理是需要用户自己设置代理服务器地址，用户必须知道代理的存在。我们设计模式中的普通代理和强制代理也是类似的一种结构，普通给代理就是我们要知道代理的存在，也就是类似于<code>GamePlayerProxy</code>这个类的存在，然后才能访问；强制代理则是调用者直接调用真实角色，而不用关心代理是否存在，其代理的产生是由真实角色决定管的，这样解释还是比较复杂，我们还是用实例来讲解。<br>首先说普通代理，他的要求就是客户端只能访问代理角色，而不能访问真实角色，这是比较简单的，我们以上面的例子作为扩展，我自己作为一个游戏玩家，我肯定自己不练级了，也即是场景类不能再直接<code>new</code>一个<code>GamePlayer</code>对象了，它必须由<code>GamePlayerProxy</code>来进行模拟场景，类图如下：<br><img src="/img/01161112_rdxV.gif" alt=""><br>改动很小，仅仅修改了两个实现类的构造函数，<code>GamePlayer</code>的构造函数增加了<code>_gamePlayer</code>参数，而代理角色则只要传入代理者的名字即可，而不需要说是替哪个对象做代理，<code>GamePlayer</code>代码清单如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name = <span class="string">''</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(IGamePlayer _gamePlayer, String _name)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (_gamePlayer == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不能创建真实角色!"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.name = _name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"在打怪"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"登录名为"</span> + user + <span class="string">" 的用户 "</span> + <span class="keyword">this</span>.name + <span class="string">"登录成功"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"又升了一级"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在构造函数中，传递进来一个<code>IGamePlayer</code>对象，检查谁能创建真实角色，当然还可以有其他的限制，比如类名必须为<code>Proxy</code>类等等，读者可以根据实际情况进行扩展。<code>GamePlayerProxy</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            gamePlayer = <span class="keyword">new</span> GamePlayer(<span class="keyword">this</span>, name);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.gamePlayer.killBoss(); </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.login(user, password);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.upgrade();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仅仅修改了构造函数，传递进来一个代理者名称，即可进行代理，在这种改造下，系统更加简洁了，调用者只知道代理存在就可以，不用知道代理了谁。<br>在该模式下，调用者只知道代理而不用知道真实角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色爱怎么修改就怎么修改，对高层次的模块没有任何影响，只要你实现了接口所对应的方法，该模式非常适合对扩展性要求高的场合。当然，在实际的项目中，一般都是通过约定来禁止<code>new</code>一个真实的角色，也是一个非常好的方案。<br>注意，普通代理模式的约束问题，尽量通过团队内的编码规范类约束，因为每一个主题类是可以被重用的和可维护的，使用技术约束的方式对系统维护是一种非常不利的因素。</p>
<h2 id="强制代理"><a href="#强制代理" class="headerlink" title="强制代理"></a>强制代理</h2><p>强制代理在设计模式中比较另类，为什么这么说呢？一般的思维都是通过代理找到真实的角色，但是强制代理却要“强制”，你必须通过真实角色查找到代理角色，否则你不能访问，甭管你是通过代理类还是通过直接<code>new</code>一个主题角色类，都不能访问，只有通过真实角色指定的代理类才能访问，也就是说由真实角色管理代理角色，这么说吧，高层模块<code>new</code>了一个真实角色的对象，返回的确实代理角色，者就好比你和一个明星比较熟，相互认识，有件事情需要向他确认一下，于是就直接拨通了明星的电话：<br>“喂，沙比呀，偶要见一下xxx导演，你帮下忙吧！”<br>“不行啊衰哥，我这几天很忙呀，你找我经纪人吧…”<br>郁闷了吧，你是想直接绕过他的代理，谁知道返回的还是他的代理，这就是强制代理，你可以不用知道代理的存在，但是你所作所为还是需要代理为你提供。我们把上面的例子稍作修改就可以完成。</p>
<p><img src="/img/clip_image010_2.gif" alt=""></p>
<p>在接口上增加了一个<code>getProxy</code>方法，真实角色<code>GamePlayer</code>可以指定一个自己的代理，除了代理外谁都不能访问。我们来看代码，先看<code>IGamePlayer</code>接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仅仅增加了一个<code>getProxy</code>方法，指定要访问自己必须通过哪个代理，实现类也要做适当的修改，先看真实角色<code>GamePlayer</code>，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String name = <span class="string">''</span>;</div><div class="line"></div><div class="line">    <span class="comment">//我要的代理是谁</span></div><div class="line">    <span class="keyword">private</span> IGamePlayer proxy = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(String _name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = _name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.proxy = <span class="keyword">new</span> GamePlayerProxy(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.proxy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isProxy()) &#123;</div><div class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">"在打怪"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"请使用指定的代理访问"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isProxy()) &#123;</div><div class="line">            System.out.println(<span class="string">"登录名为"</span>+user+<span class="string">" 的用户 "</span> + <span class="keyword">this</span>.name + <span class="string">"登录成功"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"请使用指定的代理访问"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isProxy()) &#123;</div><div class="line">            System.out.println(<span class="string">"升级"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"请使用指定的代理访问"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.proxy == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>增加了一个私有方法，检查是否是自己指定的代理，是指定的代理则允许访问，否则不允许访问。我们再来看看代理角色，代码清单如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(IGamePlayer _gamePlayer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer = _gamePlayer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.killBoss();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.login(user, password);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.gamePlayer.upgrade();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代理角色也可以再次被代理，这里我们就没有继续延伸下去了，查找代理的方法就返回自己的实例。代码都写完毕了，我们先按照常规的思路来运行一下，直接<code>new</code>一个真实的角色，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    	<span class="comment">//定义一个游戏角色</span></div><div class="line">    	IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>)；</div><div class="line">    	<span class="comment">//开始打游戏，记下时间戳</span></div><div class="line">    	System.out.println(<span class="string">"开始时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">    	player.login(<span class="string">"zhangsan"</span>, <span class="string">"password"</span>);</div><div class="line">    	player.killBoss();</div><div class="line">    	player.upgrade();</div><div class="line">    	System.out.println(<span class="string">"结束时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想看看能运行吗？</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>请使用指定的代理访问</p>
<p>请使用指定的代理访问</p>
<p>请使用指定的代理访问</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>它要求你必须通过代理来访问，你想要直接访问它，门儿都没有，好，你要我通过代理来访问，那就生产一个代理，如代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>);</div><div class="line"></div><div class="line">		IGamePlayer proxy = <span class="keyword">new</span> GamePlayerProxy(player);</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"开始时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">		</div><div class="line">		proxy.login(<span class="string">"zhangsan"</span>, <span class="string">"password"</span>);</div><div class="line"></div><div class="line">		proxy.killBoss();</div><div class="line"></div><div class="line">		proxy.upgrade();</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"结束时间是：xxxx-xx-xx xx:xx:xx"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这次能访问吗？还是不行，结果如下所示：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>请使用指定的代理访问</p>
<p>请使用指定的代理访问</p>
<p>请使用指定的代理访问</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>同样是不能访问，为什么呢？它不是真实角色指定的对象，这个代理对象是你自己new出来的，当然真实对象不认了，这就好比是那个明星，人家已经告诉你去找她的代理人了，你随便找个代理人能成吗？你必须去找她指定的代理才成！我们修改一下场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="comment">//定义个游戏的角色</span></div><div class="line">     IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>);</div><div class="line"> </div><div class="line">     <span class="comment">//获得指定的代理</span></div><div class="line">     IGamePlayer proxy = player.getProxy();</div><div class="line"> </div><div class="line">     <span class="comment">//开始打游戏，记下时间戳</span></div><div class="line">     System.out.println(<span class="string">"开始时间是：2009-8-25 10:45"</span>);</div><div class="line"> </div><div class="line">     proxy.login(<span class="string">"zhangSan"</span>, <span class="string">"password"</span>);</div><div class="line"> </div><div class="line">     <span class="comment">//开始杀怪</span></div><div class="line">     proxy.killBoss();</div><div class="line"> </div><div class="line">     <span class="comment">//升级</span></div><div class="line">     proxy.upgrade();</div><div class="line"> </div><div class="line">     <span class="comment">//记录结束游戏时间</span></div><div class="line">     System.out.println(<span class="string">"结束时间是：2009-8-26 03:40"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>登录名为zhangSan 的用户 张三登录成功！</p>
<p>张三在打怪！</p>
<p>张三 又升了一级！</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>OK，可以正常访问代理了。强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色，高层模块只要调用getProxy就可以访问真实角色的所有方法，它根本就不需要产生一个代理出来，代理的管理已经由真实角色自己完成。</p>
<h2 id="代理是有个性的"><a href="#代理是有个性的" class="headerlink" title="代理是有个性的"></a>代理是有个性的</h2><p>一个类可以实现多个接口，完成不同任务的整合，那也就是说代理类不仅仅可以实现主题接口，也可以实现其他接口完成不同的任务，而且代理的目的是在目标对象方法的基础上作增强，这种增强的本质通常就是对目标对象的方法进行拦截和过滤，例如游戏代理是需要收费的，升一级需要5元钱，这个计算功能就是代理类的个性，它应该在代理的接口中定义<br><img src="/img/01161112_LwaC.gif" alt=""><br>增加了一个IProxy接口，其作用是计算代理的费用，否则代理公司不是亏死了，我们先来看IProxy接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProxy</span> </span>&#123;</div><div class="line">	<span class="comment">//计费</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仅仅一个方法，非常简单，看<code>GamePlayerProxy</code>来的变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span>,<span class="title">IProxy</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">IGamePlayerProxy</span><span class="params">(IGamePlayer _gamePlayer)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gamePlayer = _gamePlayer;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gamePlayer.killBoss();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gamePlayer.login(user, password);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gamePlayer.upgrade();</div><div class="line">		<span class="keyword">this</span>.count();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"升级总费用是：150元"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现了IProxy接口，同时在upgrade方法中调用该方法，完成费用结算，其他的类都没有任何改动，运行结果如下：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>登录名为zhangSan 的用户 张三登录成功！</p>
<p>张三在打怪！</p>
<p>张三 又升了一级！</p>
<p>升级总费用是：150元</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>好了，代理公司也赚钱了，我的游戏也升级了，皆大欢喜。代理类不仅仅是都可以有自己的运算方法，通常的情况下代理的职责并不一定单一，它可以组合其他的真实角色，也可以实现自己的职责，比如计算费用。代理类可以为真实角色预处理消息、过滤消息、消息转发、事后处理消息等功能，当然一个代理类，可以代理多个真实角色，并且真实角色之间可以有耦合关系，读者可以自行扩展一下。</p>
<h2 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h2><p>虚拟代理(Virual Proxy)听着很复杂，其实非常简单，我们只要把代理模式的通用代码稍微修改一下就成为虚拟代理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Subject subject;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (subject == <span class="keyword">null</span>) &#123;</div><div class="line">			subject = <span class="keyword">new</span> RealSubject();</div><div class="line">		&#125;</div><div class="line">		subject.request();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在需要的时候才初始化主题对象，可以避免被代理对象较多而引起的初始化缓慢的问题，它的缺点就是需要在每个方法中判断主题对象是否被创建，这就是虚拟代理，非常简单。</p>
<p>到这里现总结一下：<br>代理模式可以提供非常好的访问控制。<br>因此一个代理类具体代理哪个真实主题角色，是由场景类决定的。<br>强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色，高层模块只要调用getProxy就可以访问真实角色的所有方法，它根本就不需要产生一个代理出来，代理的管理已经由真实角色自己完成。<br>代理类自己的个性是指：它可以有自己的方法或者实现另外的接口。<br>一个代理类可以代理多个真实角色（实现多个共同接口），然而最好不要这么做。<br>虚拟代理，创建代理的时候不进行创建，然而用的时候再进行创建—-判断试一下是否为null,为null就new 否则直接用。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>放在最后讲的一般都是压轴大戏，动态代理就是如此，上面的章节都是一个引子，动态代理才是重头戏。嘛是动态代理？动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理那一个对象，相对的来说，自己写代理类的方式就是静态代理。本章节的核心部分就在动态代理上，现在有一个非常流行的名称叫做：面向横切面编程，也就是AOP（Aspect Oriented Programming），其核心就是采用了动态代理机制，既然这么重要，我们就来看看动态代理是如何实现的，还是以打游戏为例，类图修改一下以实现动态代理。</p>
<p><img src="/img/clip_image014_2.gif" alt=""><br>在类图中增加了一个InvocationHanlder接口和GamePlayIH类，作用就是产生一个对象的代理对象，其中InvocationHanlder是JDK提供的动态代理接口，对被代理类的方法进行代理。我们来看程序，接口保持不变，实现类也没有变化，请参考前面的代码。我们来看DynamicProxy类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayIH</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">	Class cls = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	Object obj = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GamePlayIH</span><span class="params">(Object _obj)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.obj = _obj;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Ojbect[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		Object result = method.invoke(<span class="keyword">this</span>.obj, args);</div><div class="line">        <span class="keyword">return</span> result;		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中invoke方法是接口InvocationHandler定义必须实现的，它完成对真实方法的调用。我们来详细讲解一下InvocationHanlder接口，动态代理是根据被代理的接口生成所有的方法，也就是说给定一个接口，动态代理会宣称“我已经实现该接口下的所有方法了”，那各位读者想想看，动态代理怎么才能实现被代理接口中的方法呢？默认情况下所有的方法返回值都是空的，是的，代理已经实现它了，但是没有任何的逻辑含义，那怎么办？好办，通过InvocationHandler接口，所有方法都由该Handler来进行处理，即所有被代理的方法都由InvocationHandler接管实际的处理任务。</p>
<p>我们接下来看看场景类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"张三"</span>)；</div><div class="line"></div><div class="line">        InvocationHandler handler = <span class="keyword">new</span> GamePlayIH(player);</div><div class="line"></div><div class="line">        <span class="comment">//开始打游戏，记下时间戳</span></div><div class="line">        System.out.println(<span class="string">"开始时间是：2009-8-25 10:45"</span>);</div><div class="line"></div><div class="line">        ClassLoader cl = player.getClass().getClassLoader();</div><div class="line"></div><div class="line">        IGamePlayer proxy = (IGamePlayer)Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;IGamePlayer.class&#125;, handler);</div><div class="line"></div><div class="line">        proxy.login(<span class="string">"zhangsan"</span>, <span class="string">"password"</span>);</div><div class="line"></div><div class="line">        proxy.killBoss();</div><div class="line"></div><div class="line">        proxy.upgrade();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"结束时间是：2009-8-26 03:40"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很奇怪是吗？不要着急，学习是一个循序渐进的过程，继续看下去，我知道你的疑惑了。其运行结果如下：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>登录名为zhangSan 的用户 张三登录成功！</p>
<p>张三在打怪！</p>
<p>张三 又升了一级！</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>我们还是让代练者帮我们打游戏，但是我们既没有创建代理类，也没有实现IGamePlayer接口，这就是动态代理。别急，动态代理可不仅仅就这么多内容，还有更重要的，如果我们想在游戏登陆后发一个信息给我，防止账号被人盗用嘛，该怎么处理？直接修改被代理类GamePlayer？这不是一个好办法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayIH</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="comment">//被代理者</span></div><div class="line">     Class cls =<span class="keyword">null</span>;</div><div class="line"> </div><div class="line">     <span class="comment">//被代理的实例</span></div><div class="line">     Object obj = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">     <span class="comment">//我要代理谁</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">GamePlayIH</span><span class="params">(Object _obj)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.obj = _obj;</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     <span class="comment">//调用被代理的方法</span></div><div class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">         </div><div class="line">         Object result = method.invoke(<span class="keyword">this</span>.obj, args);</div><div class="line"> </div><div class="line">         <span class="comment">//如果是登录方法，则发送信息</span></div><div class="line">         <span class="keyword">if</span>(method.getName().equalsIgnoreCase(<span class="string">"login"</span>))&#123;</div><div class="line">              System.out.println(<span class="string">"有人在用我的账号登陆！"</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 看黑体部分，只要在代理中增加一个判断就可以决定是否要发送信息，运行结果如下：</p>
<p>开始时间是：2009-8-25 10:45</p>
<p>登录名为zhangSan 的用户 张三登录成功！</p>
<p>有人在用我的账号登陆！</p>
<p>张三在打怪！</p>
<p>张三 又升了一级！</p>
<p>结束时间是：2009-8-26 03:40</p>
<p>That’s very nice。 有人用我的账号就发送一个信息，然后看看自己的账号是不是被人盗了，非常好的方法，这就是AOP编程，AOP编程没有使用什么新的技术，但是它对我们的设计、编码有非常大的影响，对于日志、事务、权限等都可以在系统设计阶段不用考虑，而在设计后通过AOP的方式切过去。既然动态代理是如此的诱人，我们来看看通用动态代理模型，类图如图12-7所示。<br><img src="/img/01161112_Fpoh.gif" alt=""></p>
<p>很简单，两条独立发展的线路，动态代理实现代理的职责，业务逻辑Subject实现相关的逻辑功能，两者之间没有必然的相互耦合的关系，通知Advice从另一个切面切入，最终在高层模块也就是Client进行耦合，完成逻辑的封装任务，我们先来看Subject接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="comment">//业务操作</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String str)</span></span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的doSomething是一个标示方法，可以有多个逻辑处理方法，实现类如代码清单12-25所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="comment">//业务操作 </span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">       System.out.println(<span class="string">"do something!----&gt;"</span> + str);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点是我们的MyInvocationHandler，如代码清单12-27所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="comment">//被代理的对象</span></div><div class="line">     <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">     <span class="comment">//通过构造函数传递一个对象</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object _obj)</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.target = _obj;</div><div class="line">     &#125;</div><div class="line">    <span class="comment">//代理方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">       <span class="comment">//执行被代理的方法</span></div><div class="line">       <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.target, args);</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>非常简单，所有通过动态代理实现的方法全部通过invokve方法调用。DynamicProxy代码如代码清单12-28所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, </span></span></div><div class="line">                       Class&lt;?&gt;[] interfaces, InvocationHandler h)&#123;</div><div class="line">         <span class="comment">//寻找JoinPoint连接点，AOP框架使用元数据定义</span></div><div class="line">         <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</div><div class="line">         </div><div class="line">              <span class="comment">//执行一个前置通知</span></div><div class="line">              (<span class="keyword">new</span> BeforeAdvice()).exec();</div><div class="line">         &#125;</div><div class="line">        <span class="comment">//执行目标，并返回结果</span></div><div class="line">        <span class="keyword">return</span> (T)Proxy.newProxyInstance(loader,interfaces, h);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里插入了较多的AOP术语，在什么地方（连接点）执行什么行为（通知），我们在这里实现了一个简单的横切面编程，读者有经验的话可以看看AOP的配置文件就会明白这段代码的意义了。我们来看通知Advice，也就是我们要切入的类，比较简单，接口和实现如代码清单12-29所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAdvice</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdvice</span> <span class="keyword">implements</span> <span class="title">IAdvice</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"开是前置通知，我被执行了"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后就是看我们怎么调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="comment">//定义一个主题</span></div><div class="line">         Subject subject = <span class="keyword">new</span> RealSubject();</div><div class="line"> </div><div class="line">         <span class="comment">//定义一个Handler</span></div><div class="line">         InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(subject);</div><div class="line"> </div><div class="line">         <span class="comment">//定义主题的代理</span></div><div class="line">         Subject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(),</div><div class="line">                                            subject.getClass().getInterfaces(),handler);</div><div class="line">         <span class="comment">//代理的行为</span></div><div class="line">         proxy.doSomething(<span class="string">"Finish"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下所示：</p>
<p>我是前置通知，我被执行了！</p>
<p>do something!—-&gt;Finish</p>
<p>好，所有的程序都看完了，我们回过头来看看程序是怎么实现的。在DynamicProxy类中，我们有这样的方法：<br><code>this.obj = Proxy.newProxyInstance(c.getClassLoader(), c.getInterfaces(), new MyInvocationHandler(_obj));</code><br>该方法是重新生成了一个对象，为什么要重新生成？你要使用代理呀，注意c.getInterfaces()这句话，这是非常有意思的一句话，是说查找到该类的所有接口，然后实现接口的所有方法，当然了，方法都是空的，由谁具体负责接管呢？是new MyInvocationHandler(_Obj)这个对象，于是清楚了：一个类的动态代理类是这样的一个类，由InvocationHandler的实现类实现所有的方法，由其invoke方法接管所有方法的实现，其动态调用过程如图12-9所示。<br><img src="/img/01161112_v1d4.jpg" alt=""></p>
<p>读者可能注意到我们以上的代码还有更进一步的扩展余地，那当然了，注意看DynamicProxy类，它是一个通用类，不具有业务意义，如果我们再产生一个实现类是不是就很有意义了呢？如代码清单12-31所示。<br>代码清单12-31 具体业务的动态代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectDynamicProxy</span> <span class="keyword">extends</span> <span class="title">DynamicProxy</span></span>&#123;</div><div class="line"> </div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(Subject subject)</span></span>&#123;</div><div class="line"> </div><div class="line">          <span class="comment">//获得ClassLoader</span></div><div class="line">          ClassLoader loader = subject.getClass().getClassLoader();</div><div class="line"> </div><div class="line">          <span class="comment">//获得接口数组</span></div><div class="line">          Class&lt;?&gt;[] classes = subject.getClass().getInterfaces();</div><div class="line"> </div><div class="line">          <span class="comment">//获得handler</span></div><div class="line">          InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(subject);</div><div class="line">               <span class="keyword">return</span> newProxyInstance(loader, classes, handler);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此扩展以后，高层模块对代理的访问会更加简单，如代码清单12-32所示。</p>
<p>代码清单12-32 场景类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"> </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">         <span class="comment">//定义一个主题</span></div><div class="line">         Subject subject = <span class="keyword">new</span> RealSubject();</div><div class="line"> </div><div class="line">         <span class="comment">//定义主题的代理</span></div><div class="line">         Subject proxy = SubjectDynamicProxy.newProxyInstance(subject);</div><div class="line"> </div><div class="line">         <span class="comment">//代理的行为</span></div><div class="line">         proxy.doSomething(<span class="string">"Finish"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是不是更加简单了？可能读者就要提问了，这样与静态代理还有什么区别？都是需要实现一个代理类，有区别，注意看父类，动态代理的主要意图就是解决我们常说的“审计”问题，也就横切面编程，在不改变我们已有代码结构的情况下增强或控制对象的行为。</p>
<p>注意 要实现动态代理的首要条件是：被代理类必须实现一个接口，回想一下刚刚的分析吧。当然了，现在也有很多技术如CGLIB可以实现不需要接口也可以实现动态代理的方式。</p>
<p>再次说明，以上的动态代理是一个通用代理框架，如果你想设计自己的AOP框架，完全可以在此基础上扩展，我们设计的是一个通用代理，只要有一个接口，一个实现类，就可以使用该代理，完成代理的所有功效。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>代理模式应用的非常广泛，大到一个系统框架、企业平台，小到代码片段、事务处理，稍不留意就用到代理模式，可能该模式是大家接触最多的模式，而且有了AOP大家写代理就更加简单了，有类似Spring AOP和AspectJ这样非常优秀的工具，拿来主义即可，我们还自己写代理干嘛！不过，大家可以看看源代码，特别是调试时，只要看到类似$Proxy0这样的结构，你就应该知道这是一个动态代理了。<br>友情提醒，在学习AOP框架时，弄起初几个名词就成：切面（Aspect）、切入点(JoinPoint)、通知（Advice）、织入（Weave）就足够了，理解了这几个名词，你就可以对AOP游刃有余了！</p>

      
    </div>

    
      
      



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/image/reward/wechat.png" title="wechat">
        </label>
      
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/design-patterns/">design patterns</a>
          
            <a href="/tags/proxy/">proxy</a>
          
        </div>

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2017/02/09/装饰器模式/">
        <span class="next-text nav-default">装饰器模式</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    
  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:it.liubang@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/iliubang" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">刘邦</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    

  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://iliubang.github.io/2017/02/13/代理模式/';
        this.page.identifier = '2017/02/13/代理模式/';
        this.page.title = '代理模式';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//true.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

    <script type="text/javascript" src="/js/src/even.js?v=2.2.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.2.x"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  </body>
</html>